// Copyright © Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author David Faure <david.faure@kdab.com>
// SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-Slint-Royalty-free-2.0 OR LicenseRef-Slint-Software-3.0

// Test FlexBoxLayout respects min-width and max-width constraints
// Note: FlexBoxLayout does NOT support horizontal-stretch (items use their preferred width)

export component TestCase inherits Window {
    width: 200px;
    height: 300px;

    FlexBoxLayout {
        spacing: 5px;
        padding: 0px;

        // Item with min-width (no explicit width, should use min-width)
        r1 := Rectangle {
            background: blue;
            height: 50px;
            min-width: 80px;
        }
        // Item with explicit width
        r2 := Rectangle {
            width: 60px;
            background: red;
            height: 50px;
        }
        // Row 1 total: 80 + 5 + 60 = 145 < 200, so both fit

        // Item with max-width (larger preferred width but clamped to max-width)
        r3 := Rectangle {
            background: green;
            preferred-width: 120px;
            max-width: 80px;
            height: 50px;
        }
        // Item with both min and max constraints
        r4 := Rectangle {
            background: orange;
            min-width: 40px;
            max-width: 60px;
            height: 50px;
        }
        // Row 2: r3 (80px from max-width) + r4 (somewhere between min and max)
        // 80 + 5 + 40 = 125 < 200, so both should fit
    }

    // Row 1: r1 uses min-width (80px) + r2 (60px)
    out property <bool> test_r1: r1.x == 0px && r1.y == 0px && r1.width == 80px;
    out property <bool> test_r2: r2.x == 85px && r2.y == 0px && r2.width == 60px;

    // Row 2: r3 clamped to max-width (80px) + r4 (respects min/max)
    out property <bool> test_r3: r3.x == 0px && r3.y == 55px && r3.width == 80px;
    out property <bool> test_r4: r4.x == 85px && r4.y == 55px && r4.width >= 40px && r4.width <= 60px;

    out property <bool> test: test_r1 && test_r2 && test_r3 && test_r4;
}

/*
```cpp
auto handle = TestCase::create();
assert(handle->get_test());
```

```rust
let instance = TestCase::new().unwrap();
assert!(instance.get_test());
```
*/
