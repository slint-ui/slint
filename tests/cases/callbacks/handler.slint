// Copyright Â© SixtyFPS GmbH <info@slint.dev>
// SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-Slint-Royalty-free-2.0 OR LicenseRef-Slint-Software-3.0

TestCase := Rectangle {
    callback test_callback;
    callback test_callback2;
    callback test_callback3;
    property<int> callback_emission_count;
    test_callback => {
        callback_emission_count += 1;
        // This returns something despite the callback isn't supposed to return anything.
        // Maybe one should produce a warning in the future, but at least we shouldn't
        // result in compilation error in the generated code
        callback_emission_count
    }
    test_callback2 => {  callback_emission_count = 88; root.test_callback3(); }
}
/*
```cpp
auto handle = TestCase::create();
const TestCase &instance = *handle;
int callback_3_emitted = 0;
instance.on_test_callback3([&]{ callback_3_emitted++; });
instance.set_callback_emission_count(0);
assert_eq(instance.get_callback_emission_count(), 0);
instance.invoke_test_callback();
assert_eq(instance.get_callback_emission_count(), 1);
instance.invoke_test_callback();
assert_eq(instance.get_callback_emission_count(), 2);
assert_eq(callback_3_emitted, 0);
instance.invoke_test_callback2();
assert_eq(instance.get_callback_emission_count(), 88);
assert_eq(callback_3_emitted, 1);
```


```rust
let instance = TestCase::new().unwrap();
let callback_3_emitted = std::rc::Rc::new(std::cell::Cell::new(0));
// test that mutable variables can be captured
let mut _mutable_var = String::from("1");
instance.on_test_callback3({
    let callback_3_emitted = callback_3_emitted.clone();
    move || {
        callback_3_emitted.set(callback_3_emitted.get() + 1);
        _mutable_var.push_str(&callback_3_emitted.get().to_string());
    }
});
instance.set_callback_emission_count(0);
assert_eq!(instance.get_callback_emission_count(), 0);
instance.invoke_test_callback();
assert_eq!(instance.get_callback_emission_count(), 1);
instance.invoke_test_callback();
assert_eq!(instance.get_callback_emission_count(), 2);
assert_eq!(callback_3_emitted.get(), 0);
instance.invoke_test_callback2();
assert_eq!(instance.get_callback_emission_count(), 88);
assert_eq!(callback_3_emitted.get(), 1);
```

```js
var callback_3_emitted = 0;
var instance = new slint.TestCase({
    test_callback3: function() { callback_3_emitted++; }
});
instance.callback_emission_count = 0;
assert.equal(instance.callback_emission_count, 0);
instance.test_callback();
assert.equal(instance.callback_emission_count, 1);
let x = instance.test_callback;
assert.equal(instance.callback_emission_count, 1);
x()
assert.equal(instance.callback_emission_count, 2);
assert.equal(callback_3_emitted, 0);
instance.test_callback2();
assert.equal(instance.callback_emission_count, 88);
assert.equal(callback_3_emitted, 1);
```
*/
