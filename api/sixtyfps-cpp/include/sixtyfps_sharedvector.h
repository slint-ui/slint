/* LICENSE BEGIN
    This file is part of the SixtyFPS Project -- https://sixtyfps.io
    Copyright (c) 2020 Olivier Goffart <olivier.goffart@sixtyfps.io>
    Copyright (c) 2020 Simon Hausmann <simon.hausmann@sixtyfps.io>

    SPDX-License-Identifier: GPL-3.0-only
    This file is also available under commercial licensing terms.
    Please contact info@sixtyfps.io for more information.
LICENSE END */
#pragma once
#include "sixtyfps_sharedvector_internal.h"
#include <atomic>
#include <algorithm>

namespace sixtyfps {

template<typename T>
struct SharedVector
{
    SharedVector()
        : inner(const_cast<SharedVectorHeader*>(reinterpret_cast<const SharedVectorHeader*>(
            cbindgen_private::sixtyfps_shared_vector_empty())))
    { }

    SharedVector(const SharedVector &other)
        : inner(other.inner)
    {
        if (inner->refcount > 0) {
            ++inner->refcount;
        }
    }
    ~SharedVector()
    {
        drop();
    }
    SharedVector &operator=(const SharedVector &other)
    {
        if (other.inner == inner) { return *this; }
        drop();
        inner = other.inner;
        if (inner->refcount > 0) {
            ++inner->refcount;
        }
        return *this;
    }
    SharedVector &operator=(SharedVector &&other)
    {
        std::swap(inner, other.inner);
        return *this;
    }

    const T *cbegin() const {
        return reinterpret_cast<const T *>(inner + 1);
    }

    const T *cend() const {
        return cbegin() + inner->size;
    }

    const T *begin() const { return cbegin(); }
    const T *end() const { return cend(); }

    T *begin()  {
        detach(inner->size);
        return reinterpret_cast<T *>(inner + 1);
    }

    T *end() {
        detach(inner->size);
        return begin() + inner->size;
    }

    std::size_t size() const {
        return inner->size;
    }

    T &operator[](std::size_t index) {
        return begin()[index];
    }
    const T &operator[](std::size_t index) const {
        return begin()[index];
    }

    const T &at(std::size_t index) const {
        return begin()[index];
    }

    void push_back(const T &value) {
        detach(inner->size + 1);
        new (end()) T(value);
        inner->size++;
    }
    void push_back(T &&value) {
        detach(inner->size + 1);
        new (end()) T(std::move(value));
        inner->size++;
    }

    friend bool operator==(const SharedVector &a, const SharedVector &b) {
        if (a.size() != a.size())
            return false;
        return std::equal(a.cbegin(), a.cend(), b.cbegin());
    }
    friend bool operator!=(const SharedVector &a, const SharedVector &b) {
        return !(a == b);
    }


private:
    void detach(std::size_t expected_capacity) {
        if (inner->refcount == 1 && expected_capacity <= inner->capacity) {
            return;
        }
        auto new_array = SharedVector::with_capacity(expected_capacity);
        auto old_data = reinterpret_cast<const T *>(inner + 1);
        auto new_data = reinterpret_cast<T *>(new_array.inner + 1);
        for (std::size_t i = 0; i < inner->size; ++i) {
            new (new_data+i) T(old_data[i]);
            new_array.inner->size++;
        }
        *this = std::move(new_array);
    }

    void drop() {
        if (inner->refcount > 0 && (--inner->refcount) == 0) {
            auto b = begin(), e = end();
            for (auto it = b; it < e; ++it) {
                it->~T();
            }
            cbindgen_private::sixtyfps_shared_vector_free(
                reinterpret_cast<uint8_t *>(inner),
                sizeof(SharedVectorHeader) + inner->capacity * sizeof(T),
                alignof(SharedVectorHeader));
        }
    }

    static SharedVector with_capacity(std::size_t capacity) {
        auto mem = cbindgen_private::sixtyfps_shared_vector_allocate(
                sizeof(SharedVectorHeader) + capacity * sizeof(T),
                alignof(SharedVectorHeader));
        return SharedVector(new (mem) SharedVectorHeader{ {1}, 0, capacity });
    }

#if !defined(DOXYGEN)
    // Unfortunately, this cannot be generated by cbindgen because std::atomic is not understood
    struct SharedVectorHeader {
        std::atomic<std::intptr_t> refcount;
        std::size_t size;
        std::size_t capacity;
    };
    static_assert(alignof(T) <= alignof(SharedVectorHeader), "Not yet supported because we would need to add padding");
    SharedVectorHeader *inner;
    explicit SharedVector(SharedVectorHeader *inner) : inner(inner) {}
#endif
};

template<typename T>
bool operator==(cbindgen_private::Slice<T> a, cbindgen_private::Slice<T> b) {
    if (a.len != b.len) return false;
    return std::equal(a.ptr, a.ptr + a.len, b.ptr);
}
template<typename T>
bool operator!=(cbindgen_private::Slice<T> a, cbindgen_private::Slice<T> b) {
    return !(a != b);
}

}
