// Copyright Â© SixtyFPS GmbH <info@slint.dev>
// SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-Slint-Royalty-free-2.0 OR LicenseRef-Slint-Software-3.0

import * as napi from "../rust-module.cjs";

class ModelIterator<T> implements Iterator<T> {
    private row: number;
    private model: Model<T>;

    constructor(model: Model<T>) {
        this.model = model;
        this.row = 0;
    }

    public next(): IteratorResult<T> {
        if (this.row < this.model.rowCount()) {
            const row = this.row;
            this.row++;
            return {
                done: false,
                value: this.model.rowData(row),
            };
        }
        return {
            done: true,
            value: undefined,
        };
    }
}

/**
 * Model<T> is the interface for feeding dynamic data into
 * `.slint` views.
 *
 * A model is organized like a table with rows of data. The
 * fields of the data type T behave like columns.
 *
 * @template T the type of the model's items.
 *
 * ### Example
 * As an example let's see the implementation of {@link ArrayModel}
 *
 * ```js
 * export class ArrayModel<T> extends Model<T> {
 *    private a: Array<T>
 *
 *   constructor(arr: Array<T>) {
 *        super();
 *        this.a = arr;
 *    }
 *
 *    rowCount() {
 *        return this.a.length;
 *    }
 *
 *    rowData(row: number) {
 *       return this.a[row];
 *    }
 *
 *    setRowData(row: number, data: T) {
 *        this.a[row] = data;
 *        this.notifyRowDataChanged(row);
 *    }
 *
 *    push(...values: T[]) {
 *        let size = this.a.length;
 *        Array.prototype.push.apply(this.a, values);
 *        this.notifyRowAdded(size, arguments.length);
 *    }
 *
 *    remove(index: number, size: number) {
 *        let r = this.a.splice(index, size);
 *        this.notifyRowRemoved(index, size);
 *    }
 *
 *    get length(): number {
 *        return this.a.length;
 *    }
 *
 *    values(): IterableIterator<T> {
 *        return this.a.values();
 *    }
 *
 *    entries(): IterableIterator<[number, T]> {
 *        return this.a.entries()
 *    }
 *}
 * ```
 */
export abstract class Model<T> implements Iterable<T> {
    /**
     * @hidden
     */
    modelNotify: napi.ExternalObject<napi.SharedModelNotify>;

    constructor() {
        this.modelNotify = napi.jsModelNotifyNew(this);
    }

    // /**
    //  * Returns a new Model where all elements are mapped by the function `mapFunction`.
    //  * @template T the type of the source model's items.
    //  * @param mapFunction functions that maps
    //  * @returns a new {@link MapModel} that wraps the current model.
    //  */
    // map<U>(
    //     mapFunction: (data: T) => U
    // ): MapModel<T, U> {
    //     return new MapModel(this, mapFunction);
    // }

    /**
     * Implementations of this function must return the current number of rows.
     */
    abstract rowCount(): number;
    /**
     * Implementations of this function must return the data at the specified row.
     * @param row index in range 0..(rowCount() - 1).
     * @returns undefined if row is out of range otherwise the data.
     */
    abstract rowData(row: number): T | undefined;

    /**
     * Implementations of this function must store the provided data parameter
     * in the model at the specified row.
     * @param _row index in range 0..(rowCount() - 1).
     * @param _data new data item to store on the given row index
     */
    setRowData(_row: number, _data: T): void {
        console.log(
            "setRowData called on a model which does not re-implement this method. This happens when trying to modify a read-only model",
        );
    }

    [Symbol.iterator](): Iterator<T> {
        return new ModelIterator(this);
    }

    /**
     * Notifies the view that the data of the current row is changed.
     * @param row index of the changed row.
     */
    protected notifyRowDataChanged(row: number): void {
        napi.jsModelNotifyRowDataChanged(this.modelNotify, row);
    }

    /**
     * Notifies the view that multiple rows are added to the model.
     * @param row index of the first added row.
     * @param count the number of added items.
     */
    protected notifyRowAdded(row: number, count: number): void {
        napi.jsModelNotifyRowAdded(this.modelNotify, row, count);
    }

    /**
     * Notifies the view that multiple rows are removed to the model.
     * @param row index of the first removed row.
     * @param count the number of removed items.
     */
    protected notifyRowRemoved(row: number, count: number): void {
        napi.jsModelNotifyRowRemoved(this.modelNotify, row, count);
    }

    /**
     * Notifies the view that the complete data must be reload.
     */
    protected notifyReset(): void {
        napi.jsModelNotifyReset(this.modelNotify);
    }
}

/**
 * ArrayModel wraps a JavaScript array for use in `.slint` views. The underlying
 * array can be modified with the [[ArrayModel.push]] and [[ArrayModel.remove]] methods.
 */
export class ArrayModel<T> extends Model<T> {
    /**
     * @hidden
     */
    #array: Array<T>;

    /**
     * Creates a new ArrayModel.
     *
     * @param arr
     */
    constructor(arr: Array<T>) {
        super();
        this.#array = arr;
    }

    /**
     * Returns the number of entries in the array model.
     */
    get length(): number {
        return this.#array.length;
    }

    /**
     * Returns the number of entries in the array model.
     */
    rowCount() {
        return this.#array.length;
    }

    /**
     * Returns the data at the specified row.
     * @param row index in range 0..(rowCount() - 1).
     * @returns undefined if row is out of range otherwise the data.
     */
    rowData(row: number) {
        return this.#array[row];
    }

    /**
     * Stores the given data on the given row index and notifies run-time about the changed row.
     * @param row index in range 0..(rowCount() - 1).
     * @param data new data item to store on the given row index
     */
    setRowData(row: number, data: T) {
        this.#array[row] = data;
        this.notifyRowDataChanged(row);
    }

    /**
     * Pushes new values to the array that's backing the model and notifies
     * the run-time about the added rows.
     * @param values list of values that will be pushed to the array.
     */
    push(...values: T[]) {
        const size = this.#array.length;
        Array.prototype.push.apply(this.#array, values);
        this.notifyRowAdded(size, arguments.length);
    }

    /**
     * Removes the last element from the array and returns it.
     *
     * @returns The removed element or undefined if the array is empty.
     */
    pop(): T | undefined {
        const last = this.#array.pop();
        if (last !== undefined) {
            this.notifyRowRemoved(this.#array.length, 1);
        }
        return last;
    }

    // FIXME: should this be named splice and have the splice api?
    /**
     * Removes the specified number of element from the array that's backing
     * the model, starting at the specified index.
     * @param index index of first row to remove.
     * @param size number of rows to remove.
     */
    remove(index: number, size: number) {
        const r = this.#array.splice(index, size);
        this.notifyRowRemoved(index, size);
    }

    /**
     * Returns an iterable of values in the array.
     */
    values(): IterableIterator<T> {
        return this.#array.values();
    }

    /**
     * Returns an iterable of key, value pairs for every entry in the array.
     */
    entries(): IterableIterator<[number, T]> {
        return this.#array.entries();
    }
}

/**
 * Provides rows that are generated by a map function based on the rows of another Model.
 *
 * @template T item type of source model that is mapped to U.
 * @template U the type of the mapped items
 *
 * ## Example
 *
 *  Here we have a {@link ArrayModel} holding rows of a custom interface `Name` and a {@link MapModel} that maps the name rows
 *  to single string rows.
 *
 * ```ts
 * import { Model, ArrayModel, MapModel } from "./index";
 *
 * interface Name {
 *     first: string;
 *     last: string;
 * }
 *
 * const model = new ArrayModel<Name>([
 *     {
 *         first: "Hans",
 *         last: "Emil",
 *     },
 *     {
 *         first: "Max",
 *         last: "Mustermann",
 *     },
 *     {
 *         first: "Roman",
 *         last: "Tisch",
 *     },
 * ]);
 *
 * const mappedModel = new MapModel(
 *     model,
 *     (data) => {
 *         return data.last + ", " + data.first;
 *     }
 * );
 *
 * // prints "Emil, Hans"
 * console.log(mappedModel.rowData(0));
 *
 * // prints "Mustermann, Max"
 * console.log(mappedModel.rowData(1));
 *
 * // prints "Tisch, Roman"
 * console.log(mappedModel.rowData(2));
 *
 * // Alternatively you can use the shortcut {@link MapModel.map}.
 *
 * const model = new ArrayModel<Name>([
 *     {
 *         first: "Hans",
 *         last: "Emil",
 *     },
 *     {
 *         first: "Max",
 *         last: "Mustermann",
 *     },
 *     {
 *         first: "Roman",
 *         last: "Tisch",
 *     },
 * ]);
 *
 * const mappedModel = model.map(
 *     (data) => {
 *         return data.last + ", " + data.first;
 *     }
 * );
 *
 *
 * // prints "Emil, Hans"
 * console.log(mappedModel.rowData(0));
 *
 * // prints "Mustermann, Max"
 * console.log(mappedModel.rowData(1));
 *
 * // prints "Tisch, Roman"
 * console.log(mappedModel.rowData(2));
 *
 * // You can modifying the underlying {@link ArrayModel}:
 *
 * const model = new ArrayModel<Name>([
 *     {
 *         first: "Hans",
 *         last: "Emil",
 *     },
 *     {
 *         first: "Max",
 *         last: "Mustermann",
 *     },
 *     {
 *         first: "Roman",
 *         last: "Tisch",
 *     },
 * ]);
 *
 * const mappedModel = model.map(
 *     (data) => {
 *         return data.last + ", " + data.first;
 *     }
 * );
 *
 * model.setRowData(1, { first: "Minnie", last: "Musterfrau" } );
 *
 * // prints "Emil, Hans"
 * console.log(mappedModel.rowData(0));
 *
 * // prints "Musterfrau, Minnie"
 * console.log(mappedModel.rowData(1));
 *
 * // prints "Tisch, Roman"
 * console.log(mappedModel.rowData(2));
 * ```
 */
export class MapModel<T, U> extends Model<U> {
    readonly sourceModel: Model<T>;
    #mapFunction: (data: T) => U;

    /**
     * Constructs the MapModel with a source model and map functions.
     * @template T item type of source model that is mapped to U.
     * @template U the type of the mapped items.
     * @param sourceModel the wrapped model.
     * @param mapFunction maps the data from T to U.
     */
    constructor(sourceModel: Model<T>, mapFunction: (data: T) => U) {
        super();
        this.sourceModel = sourceModel;
        this.#mapFunction = mapFunction;
    }

    /**
     * Returns the number of entries in the model.
     */
    rowCount(): number {
        return this.sourceModel.rowCount();
    }

    /**
     * Returns the data at the specified row.
     * @param row index in range 0..(rowCount() - 1).
     * @returns undefined if row is out of range otherwise the data.
     */
    rowData(row: number): U | undefined {
        const data = this.sourceModel.rowData(row);
        if (data === undefined) {
            return undefined;
        }
        return this.#mapFunction(data);
    }
}
