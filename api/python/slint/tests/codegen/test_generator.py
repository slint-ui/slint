# Copyright Â© SixtyFPS GmbH <info@slint.dev>
# SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-Slint-Royalty-free-2.0 OR LicenseRef-Slint-Software-3.0

from __future__ import annotations

import importlib
import importlib.util
import inspect
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Any

import pytest
from slint.codegen.cli import _parse_library_paths
from slint.codegen.cli import main as cli_main
from slint.codegen.generator import generate_project
from slint.codegen.models import GenerationConfig


def _write_slint_fixture(target_dir: Path) -> Path:
    source = inspect.cleandoc(
        """
        export struct Config {
            value: int,
            label: string,
        }

        export enum Choice {
            first,
            second,
        }

        export global SharedLogic {
            out property <int> total: 0;
            callback notify(int);
        }

        export component AppWindow inherits Window {
            width: 160px;
            height: 80px;
            in-out property <int> counter: SharedLogic.total;
            in-out property <TextHorizontalAlignment> alignment: TextHorizontalAlignment.center;
            callback activated(int);

            public function reset() -> int {
                SharedLogic.notify(counter);
                return counter;
            }

            Text {
                text: counter;
                horizontal-alignment: alignment;
            }
        }
        """
    )

    slint_dir = target_dir / "ui"
    slint_dir.mkdir(parents=True, exist_ok=True)
    slint_file = slint_dir / "app.slint"
    slint_file.write_text(source + "\n", encoding="utf-8")
    return slint_file


def _write_optional_fixture(target_dir: Path) -> Path:
    import inspect

    source = inspect.cleandoc(
        """
        export struct OptionalInt := {
            maybe_value: int,
        }

        export struct OptionalFloat := {
            maybe_value: float,
        }

        export struct OptionalString := {
            maybe_value: string,
        }

        export struct OptionalBool := {
            maybe_value: bool,
        }

        export component OptionalDemo {
            in-out property <OptionalInt> maybe_count;
            callback on_action(value: OptionalFloat) -> OptionalInt;

            public function compute(input: OptionalString) -> OptionalBool {
                return { maybe_value: true };
            }
        }
        """
    )

    slint_dir = target_dir / "optional"
    slint_dir.mkdir(parents=True, exist_ok=True)
    slint_file = slint_dir / "optional.slint"
    slint_file.write_text(source + "\n", encoding="utf-8")
    return slint_file


def _load_module(module_path: Path) -> Any:
    spec = importlib.util.spec_from_file_location("generated_module", module_path)
    assert spec and spec.loader
    module = importlib.util.module_from_spec(spec)
    sys.modules.pop("generated_module", None)
    spec.loader.exec_module(module)
    return module


def test_generate_project_creates_runtime_and_stub(tmp_path: Path) -> None:
    slint_file = _write_slint_fixture(tmp_path)
    output_dir = tmp_path / "generated"
    config = GenerationConfig(
        include_paths=[slint_file.parent],
        library_paths={},
        style=None,
        translation_domain=None,
        quiet=True,
    )

    generate_project(inputs=[slint_file], output_dir=output_dir, config=config)

    py_file = output_dir / "app.py"
    pyi_file = output_dir / "app.pyi"
    slint_copy = output_dir / "app.slint"

    assert py_file.exists()
    assert pyi_file.exists()
    assert slint_copy.exists()

    runtime_src = py_file.read_text(encoding="utf-8")
    assert "Generated by slint.codegen" in runtime_src
    assert "AppWindow = _module.AppWindow" in runtime_src
    assert "Config = _module.Config" in runtime_src
    assert "Choice = _module.Choice" in runtime_src

    stub_src = pyi_file.read_text(encoding="utf-8")
    assert "class AppWindow" in stub_src
    assert "class Config" in stub_src
    assert "class Choice" in stub_src
    assert "class SharedLogic" in stub_src
    assert "counter: int" in stub_src
    assert "TextHorizontalAlignment" not in stub_src
    assert "alignment: Any" in stub_src
    assert "activated: Callable[[int], None]" in stub_src
    assert "reset: Callable[[], int]" in stub_src
    assert "notify: Callable[[int], None]" in stub_src
    assert "from typing import" in stub_src
    assert "Any" in stub_src
    assert "Callable" in stub_src
    assert "def __init__(self, *, " in stub_src
    assert "value:" in stub_src
    assert "label:" in stub_src

    module = _load_module(py_file)
    assert hasattr(module, "AppWindow")
    instance = module.AppWindow()
    assert hasattr(instance, "show")
    assert instance.reset() == 0
    alignment = instance.alignment
    alignment_type = alignment.__class__
    assert alignment_type.__name__ == "TextHorizontalAlignment"
    assert alignment == alignment_type.center

    config_struct = module.Config(value=5, label="demo")
    assert config_struct.value == 5


def test_cli_generate(tmp_path: Path) -> None:
    slint_file = _write_slint_fixture(tmp_path)
    output_dir = tmp_path / "out"

    cmd = [
        sys.executable,
        "-m",
        "slint.codegen",
        "generate",
        "--input",
        str(slint_file),
        "--output",
        str(output_dir),
        "--quiet",
    ]
    subprocess.run(cmd, check=True)

    assert (output_dir / "app.py").exists()
    assert (output_dir / "app.pyi").exists()


def test_generate_optional_type_hints(tmp_path: Path) -> None:
    slint_file = _write_optional_fixture(tmp_path)
    output_dir = tmp_path / "optional-generated"
    config = GenerationConfig(
        include_paths=[slint_file.parent],
        library_paths={},
        style=None,
        translation_domain=None,
        quiet=True,
    )

    generate_project(inputs=[slint_file], output_dir=output_dir, config=config)

    stub_src = (output_dir / "optional.pyi").read_text(encoding="utf-8")
    assert "maybe_count: Optional[int]" in stub_src
    assert "on_action: Callable[[Optional[float]], Optional[int]]" in stub_src
    assert "compute: Callable[[Optional[str]], Optional[bool]]" in stub_src
    assert "from typing import" in stub_src
    assert "Any" in stub_src
    assert "Callable" in stub_src
    assert "Optional" in stub_src


def test_cli_main_without_subcommand(tmp_path: Path) -> None:
    slint_file = _write_slint_fixture(tmp_path)
    exit_code = cli_main(
        [
            "--input",
            str(slint_file),
            "--quiet",
        ]
    )

    assert exit_code == 0
    assert (slint_file.parent / "app.py").exists()


def test_counter_example_workflow(tmp_path: Path) -> None:
    project_root = Path(__file__).resolve().parent
    example_src = project_root / "examples" / "counter"
    example_copy = tmp_path / "examples" / "counter"
    shutil.copytree(example_src, example_copy)

    subprocess.run([sys.executable, "generate.py"], cwd=example_copy, check=True)
    generated_py = example_copy / "counter.py"
    assert generated_py.exists()
    package_init = tmp_path / "examples" / "__init__.py"
    package_init.parent.mkdir(parents=True, exist_ok=True)
    package_init.touch()

    sys.path.insert(0, str(tmp_path))
    try:
        for name in [
            "examples.counter.main",
            "examples.counter.counter",
            "examples.counter",
            "examples",
        ]:
            sys.modules.pop(name, None)
        assert importlib.util.find_spec("examples.counter.counter") is not None
        module = importlib.import_module("examples.counter.main")
    finally:
        sys.path.pop(0)

    app = module.CounterApp()
    assert app.counter == 0
    app.request_increase()
    assert app.counter == 1


def test_parse_library_paths_and_error_handling() -> None:
    mapping = _parse_library_paths(["std=path/to/std"])
    assert mapping == {"std": Path("path/to/std")}

    with pytest.raises(SystemExit):
        _parse_library_paths(["missing_delimiter"])


def test_generate_project_requires_sources(tmp_path: Path) -> None:
    config = GenerationConfig(
        include_paths=[],
        library_paths={},
        style=None,
        translation_domain=None,
        quiet=True,
    )
    with pytest.raises(SystemExit):
        generate_project(inputs=[tmp_path], output_dir=tmp_path / "o", config=config)
