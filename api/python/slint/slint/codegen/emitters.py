# Copyright Â© SixtyFPS GmbH <info@slint.dev>
# SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-Slint-Royalty-free-2.0 OR LicenseRef-Slint-Software-3.0

from __future__ import annotations

import inspect
import os
import re
from pathlib import Path

import libcst as cst

from ..api import _normalize_prop
from .models import CallbackMeta, GenerationConfig, ModuleArtifacts, StructMeta


def module_relative_path_expr(module_dir: Path, target: Path) -> str:
    try:
        rel = os.path.relpath(target, module_dir)
    except ValueError:
        return f"Path({repr(str(target))})"

    if rel in (".", ""):
        return "_MODULE_DIR"

    parts = Path(rel).parts
    expr = "_MODULE_DIR"
    for part in parts:
        if part == ".":
            continue
        expr += f" / {repr(part)}"
    return expr


def _collect_export_bindings(
    artifacts: ModuleArtifacts, *, include_builtin_enums: bool
) -> dict[str, str]:
    bindings: dict[str, str] = {}

    for component in artifacts.components:
        bindings[component.name] = component.py_name

    for struct in artifacts.structs:
        bindings[struct.name] = struct.py_name

    for enum in artifacts.enums:
        if enum.is_builtin and not include_builtin_enums:
            continue
        if not enum.is_builtin:
            bindings[enum.name] = enum.py_name
        elif include_builtin_enums:
            bindings[enum.name] = enum.py_name

    return bindings


def _format_import(module: str, names: list[str]) -> str:
    if not names:
        raise ValueError("Expected at least one name to import")

    if len(names) == 1:
        return f"from {module} import {names[0]}"

    joined = ",\n    ".join(names)
    return f"from {module} import (\n    {joined},\n)"


def _unique_preserve_order(values: list[str]) -> list[str]:
    seen: set[str] = set()
    result: list[str] = []
    for value in values:
        if value in seen:
            continue
        seen.add(value)
        result.append(value)
    return result


def _collect_named_aliases(
    artifacts: ModuleArtifacts,
    export_bindings: dict[str, str],
    *,
    allowed_originals: set[str] | None = None,
) -> tuple[list[str], list[str]]:
    alias_names: list[str] = []
    alias_statements: list[str] = []

    for original, alias in artifacts.named_exports:
        if allowed_originals is not None and original not in allowed_originals:
            continue
        alias_name = _normalize_prop(alias)
        target = export_bindings.get(original, _normalize_prop(original))
        alias_names.append(alias_name)
        alias_statements.append(f"{alias_name} = {target}")

    return alias_names, alias_statements


def _write_struct_python_module(
    path: Path,
    *,
    source_relative: str,
    resource_name: str,
    export_items: list[str],
    include_expr_code: str,
    library_expr_code: str,
    style_expr: str,
    domain_expr: str,
    artifacts: ModuleArtifacts,
    export_bindings: dict[str, str],
) -> None:
    def _stmt(code: str) -> cst.BaseStatement:
        return cst.parse_statement(code)

    header: list[cst.CSTNode] = [
        cst.EmptyLine(
            comment=cst.Comment(f"# Generated by slint.codegen from {source_relative}")
        )
    ]

    body: list[cst.CSTNode] = [
        _stmt("from __future__ import annotations"),
        cst.EmptyLine(),
        _stmt("import importlib.resources as _resources"),
        _stmt("import os"),
        _stmt("import types"),
        _stmt("from contextlib import nullcontext as _nullcontext"),
        _stmt("from pathlib import Path"),
        _stmt("from typing import Any"),
        cst.EmptyLine(),
        _stmt("import slint"),
        _stmt("from slint import core as _core"),
        _stmt("from slint.api import _build_struct"),
        cst.EmptyLine(),
    ]

    all_list = cst.List(
        elements=[cst.Element(cst.SimpleString(repr(item))) for item in export_items]
    )
    body.append(
        cst.SimpleStatementLine(
            [
                cst.Assign(
                    targets=[cst.AssignTarget(cst.Name("__all__"))], value=all_list
                )
            ]
        )
    )
    body.append(cst.EmptyLine())

    body.append(_stmt("_MODULE_DIR = Path(__file__).parent"))
    body.append(cst.EmptyLine())

    body.append(
        cst.SimpleStatementLine(
            [
                cst.Assign(
                    targets=[cst.AssignTarget(cst.Name("_SLINT_RESOURCE"))],
                    value=cst.SimpleString(repr(resource_name)),
                )
            ]
        )
    )
    body.append(cst.EmptyLine())

    struct_lines: list[str] = []
    for struct in artifacts.structs:
        struct_lines.append(
            f"    if {struct.name!r} in structs:\n"
            f"        module.{struct.py_name} = _build_struct({struct.py_name!r}, structs[{struct.name!r}])"
        )

    enum_lines: list[str] = []
    for enum in artifacts.enums:
        if enum.is_builtin:
            continue
        enum_lines.append(
            f"    if {enum.name!r} in enums:\n"
            f"        module.{enum.py_name} = enums[{enum.name!r}]"
        )

    alias_lines: list[str] = []
    for orig, alias in artifacts.named_exports:
        alias_name = _normalize_prop(alias)
        target_name = export_bindings.get(orig, _normalize_prop(orig))
        alias_lines.append(
            f"    if hasattr(module, {target_name!r}):\n"
            f"        module.{alias_name} = getattr(module, {target_name!r})"
        )

    with_lines = [
        "with ctx as slint_path:",
        f"    include_paths: list[os.PathLike[Any] | Path] | None = {include_expr_code}",
        f"    library_paths: dict[str, os.PathLike[Any] | Path] | None = {library_expr_code}",
        f"    style = {style_expr}",
        f"    translation_domain = {domain_expr}",
        "    compiler = _core.Compiler()",
        "    if include_paths is not None:",
        "        compiler.include_paths = include_paths  # type: ignore[assignment]",
        "    if library_paths is not None:",
        "        compiler.library_paths = library_paths  # type: ignore[assignment]",
        "    if style is not None:",
        "        compiler.style = style",
        "    if translation_domain is not None:",
        "        compiler.set_translation_domain(translation_domain)",
        "    result = compiler.build_from_path(slint_path)",
        "    diagnostics = result.diagnostics",
        "    errors = [",
        "        diag",
        "        for diag in diagnostics",
        "        if diag.level == _core.DiagnosticLevel.Error",
        "        and diag.message != 'No component found'",
        "    ]",
        "    if errors:",
        f"        raise slint.CompileError({source_relative!r}, diagnostics)",
        "    module = types.SimpleNamespace()",
        "    structs, enums = result.structs_and_enums",
        *struct_lines,
        *enum_lines,
        *alias_lines,
        "    return module",
    ]

    load_statements: list[cst.BaseStatement] = [
        _stmt('"""Load struct and enum definitions for this package."""'),
        _stmt("package = __package__ or (__spec__.parent if __spec__ else None)"),
        _stmt(
            "if package:\n"
            "    ctx = _resources.as_file(_resources.files(package).joinpath(_SLINT_RESOURCE))\n"
            "else:\n"
            "    ctx = _nullcontext(Path(__file__).with_name(_SLINT_RESOURCE))"
        ),
        _stmt("\n".join(with_lines)),
    ]

    load_func = cst.FunctionDef(
        name=cst.Name("_load"),
        params=cst.Parameters(),
        returns=cst.Annotation(
            annotation=cst.Attribute(
                value=cst.Name("types"),
                attr=cst.Name("SimpleNamespace"),
            )
        ),
        body=cst.IndentedBlock(body=load_statements),
    )

    body.append(load_func)
    body.append(cst.EmptyLine())
    body.append(_stmt("_module = _load()"))
    body.append(cst.EmptyLine())

    for original, binding in export_bindings.items():
        module_attr = _normalize_prop(original)
        body.append(_stmt(f"{binding} = _module.{module_attr}"))

    for orig, alias in artifacts.named_exports:
        alias_name = _normalize_prop(alias)
        target = export_bindings.get(orig, _normalize_prop(orig))
        body.append(_stmt(f"{alias_name} = {target}"))

    module = cst.Module(body=header + body)  # type: ignore[arg-type]
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(module.code, encoding="utf-8")


def write_python_module(
    path: Path,
    *,
    source_relative: str,
    resource_name: str,
    config: GenerationConfig,
    artifacts: ModuleArtifacts,
) -> None:
    def _stmt(code: str) -> cst.BaseStatement:
        return cst.parse_statement(code)

    module_dir = path.parent

    include_exprs = [
        module_relative_path_expr(module_dir, include_path)
        for include_path in config.include_paths
    ]
    include_expr_code = f"[{', '.join(include_exprs)}]" if include_exprs else "None"

    library_items = [
        f"{repr(name)}: {module_relative_path_expr(module_dir, lib_path)}"
        for name, lib_path in config.library_paths.items()
    ]
    library_expr_code = f"{{{', '.join(library_items)}}}" if library_items else "None"

    style_expr = repr(config.style) if config.style is not None else "None"
    domain_expr = (
        repr(config.translation_domain)
        if config.translation_domain is not None
        else "None"
    )

    export_bindings = _collect_export_bindings(artifacts, include_builtin_enums=False)

    export_items = list(export_bindings.values()) + [
        _normalize_prop(alias) for _, alias in artifacts.named_exports
    ]

    if not artifacts.components:
        _write_struct_python_module(
            path,
            source_relative=source_relative,
            resource_name=resource_name,
            export_items=export_items,
            include_expr_code=include_expr_code,
            library_expr_code=library_expr_code,
            style_expr=style_expr,
            domain_expr=domain_expr,
            artifacts=artifacts,
            export_bindings=export_bindings,
        )
        return

    header: list[cst.CSTNode] = [
        cst.EmptyLine(
            comment=cst.Comment(f"# Generated by slint.codegen from {source_relative}")
        )
    ]

    body: list[cst.CSTNode] = [
        _stmt("from __future__ import annotations"),
        cst.EmptyLine(),
        _stmt("import importlib.resources as _resources"),
        _stmt("import os"),
        _stmt("import types"),
        _stmt("from contextlib import nullcontext as _nullcontext"),
        _stmt("from pathlib import Path"),
        _stmt("from typing import Any"),
        cst.EmptyLine(),
        _stmt("import slint"),
        cst.EmptyLine(),
    ]

    all_list = cst.List(
        elements=[cst.Element(cst.SimpleString(repr(item))) for item in export_items]
    )
    body.append(
        cst.SimpleStatementLine(
            [
                cst.Assign(
                    targets=[cst.AssignTarget(cst.Name("__all__"))], value=all_list
                )
            ]
        )
    )
    body.append(cst.EmptyLine())

    body.append(_stmt("_MODULE_DIR = Path(__file__).parent"))
    body.append(cst.EmptyLine())

    body.append(
        cst.SimpleStatementLine(
            [
                cst.Assign(
                    targets=[cst.AssignTarget(cst.Name("_SLINT_RESOURCE"))],
                    value=cst.SimpleString(repr(resource_name)),
                )
            ]
        )
    )
    body.append(cst.EmptyLine())

    load_source = inspect.cleandoc(
        f'''
        def _load() -> types.SimpleNamespace:
            """Load the compiled Slint module for this package."""
            package = __package__ or (__spec__.parent if __spec__ else None)
            if package:
                ctx = _resources.as_file(_resources.files(package).joinpath(_SLINT_RESOURCE))
            else:
                ctx = _nullcontext(Path(__file__).with_name(_SLINT_RESOURCE))
            with ctx as slint_path:
                include_paths: list[os.PathLike[Any] | Path] | None = {include_expr_code}
                library_paths: dict[str, os.PathLike[Any] | Path] | None = {library_expr_code}
                return slint.load_file(
                    path=slint_path,
                    quiet=True,
                    style={style_expr},
                    include_paths=include_paths,
                    library_paths=library_paths,
                    translation_domain={domain_expr},
                )
        '''
    )

    load_func = cst.parse_module(load_source).body[0]

    body.append(load_func)
    body.append(cst.EmptyLine())
    body.append(_stmt("_module = _load()"))
    body.append(cst.EmptyLine())

    for original, binding in export_bindings.items():
        module_attr = _normalize_prop(original)
        body.append(_stmt(f"{binding} = _module.{module_attr}"))
    for orig, alias in artifacts.named_exports:
        alias_name = _normalize_prop(alias)
        target = export_bindings.get(orig, _normalize_prop(orig))
        body.append(_stmt(f"{alias_name} = {target}"))

    module = cst.Module(body=header + body)  # type: ignore[arg-type]
    path.write_text(module.code, encoding="utf-8")


def write_stub_module(path: Path, *, artifacts: ModuleArtifacts) -> None:
    def _stmt(code: str) -> cst.BaseStatement:
        return cst.parse_statement(code)

    typing_imports: set[str] = set()

    def register_type(type_str: str) -> None:
        if not type_str:
            return
        normalized = type_str.replace("typing.", "")
        tokens = set(token for token in re.split(r"[^A-Za-z_]+", normalized) if token)
        for token in ("Any", "Callable", "Literal", "Optional", "Union"):
            if token in tokens:
                typing_imports.add(token)

    post_body: list[cst.CSTNode] = []

    needs_enum_import = any(not enum.is_builtin for enum in artifacts.enums)

    export_names = [component.py_name for component in artifacts.components]
    export_names += [struct.py_name for struct in artifacts.structs]
    export_names += [enum.py_name for enum in artifacts.enums if not enum.is_builtin]
    export_names += [_normalize_prop(alias) for _, alias in artifacts.named_exports]
    if export_names:
        all_list = cst.List(
            elements=[
                cst.Element(cst.SimpleString(repr(name))) for name in export_names
            ]
        )
        post_body.append(
            cst.SimpleStatementLine(
                [
                    cst.Assign(
                        targets=[cst.AssignTarget(cst.Name("__all__"))], value=all_list
                    )
                ]
            )
        )
        post_body.append(cst.EmptyLine())

    def ann_assign(name: str, type_expr: str) -> cst.BaseStatement:
        return cst.SimpleStatementLine(
            [
                cst.AnnAssign(
                    target=cst.Name(name),
                    annotation=cst.Annotation(
                        annotation=cst.parse_expression(type_expr)
                    ),
                    value=None,
                )
            ]
        )

    def ellipsis_line() -> cst.BaseStatement:
        return cst.SimpleStatementLine([cst.Expr(value=cst.Ellipsis())])

    def ellipsis_suite() -> cst.BaseSuite:
        return cst.SimpleStatementSuite([cst.Expr(value=cst.Ellipsis())])

    def struct_init_stub(struct: StructMeta) -> cst.FunctionDef:
        params = [cst.Param(name=cst.Name("self"))]
        kwonly_params: list[cst.Param] = []

        for field in struct.fields:
            register_type(field.type_hint)
            kwonly_params.append(
                cst.Param(
                    name=cst.Name(field.py_name),
                    annotation=cst.Annotation(
                        annotation=cst.parse_expression(field.type_hint)
                    ),
                    default=cst.Ellipsis(),
                )
            )

        parameters = cst.Parameters(params=params, kwonly_params=kwonly_params)

        if not struct.fields:
            parameters = cst.Parameters(params=params)

        return cst.FunctionDef(
            name=cst.Name("__init__"),
            params=parameters,
            returns=cst.Annotation(annotation=cst.Name("None")),
            body=ellipsis_suite(),
        )

    def component_init_stub() -> cst.FunctionDef:
        typing_imports.add("Any")
        return cst.FunctionDef(
            name=cst.Name("__init__"),
            params=cst.Parameters(
                params=[cst.Param(name=cst.Name("self"))],
                star_kwarg=cst.Param(
                    name=cst.Name("kwargs"),
                    annotation=cst.Annotation(annotation=cst.Name("Any")),
                ),
            ),
            returns=cst.Annotation(annotation=cst.Name("None")),
            body=ellipsis_suite(),
        )

    for struct in artifacts.structs:
        struct_body: list[cst.BaseStatement] = [struct_init_stub(struct)]
        if struct.fields:
            for field in struct.fields:
                register_type(field.type_hint)
                struct_body.append(ann_assign(field.py_name, field.type_hint))
        else:
            struct_body.append(ellipsis_line())
        post_body.append(
            cst.ClassDef(
                name=cst.Name(struct.py_name),
                bases=[],
                body=cst.IndentedBlock(body=struct_body),
            )
        )
        post_body.append(cst.EmptyLine())

    for enum_meta in artifacts.enums:
        if enum_meta.is_builtin:
            continue
        enum_body: list[cst.BaseStatement] = []
        if enum_meta.values:
            for value in enum_meta.values:
                enum_body.append(
                    cst.SimpleStatementLine(
                        [
                            cst.Assign(
                                targets=[cst.AssignTarget(cst.Name(value.py_name))],
                                value=cst.SimpleString(repr(value.value)),
                            )
                        ]
                    )
                )
        else:
            enum_body.append(ellipsis_line())
        post_body.append(
            cst.ClassDef(
                name=cst.Name(enum_meta.py_name),
                bases=[
                    cst.Arg(
                        value=cst.Attribute(
                            value=cst.Name("enum"), attr=cst.Name("Enum")
                        )
                    )
                ],
                body=cst.IndentedBlock(body=enum_body),
            )
        )
        post_body.append(cst.EmptyLine())

    for component in artifacts.components:
        component_body: list[cst.BaseStatement] = [component_init_stub()]
        for prop in component.properties:
            register_type(prop.type_hint)
            component_body.append(ann_assign(prop.py_name, prop.type_hint))
        for callback in component.callbacks:
            annotation = format_callable_annotation(callback)
            register_type(annotation)
            component_body.append(ann_assign(callback.py_name, annotation))
        for fn in component.functions:
            annotation = format_callable_annotation(fn)
            register_type(annotation)
            component_body.append(ann_assign(fn.py_name, annotation))
        for global_meta in component.globals:
            inner_body: list[cst.BaseStatement] = []
            if not (
                global_meta.properties or global_meta.callbacks or global_meta.functions
            ):
                inner_body.append(ellipsis_line())
            else:
                for prop in global_meta.properties:
                    register_type(prop.type_hint)
                    inner_body.append(ann_assign(prop.py_name, prop.type_hint))
                for callback in global_meta.callbacks:
                    annotation = format_callable_annotation(callback)
                    register_type(annotation)
                    inner_body.append(ann_assign(callback.py_name, annotation))
                for fn in global_meta.functions:
                    annotation = format_callable_annotation(fn)
                    register_type(annotation)
                    inner_body.append(ann_assign(fn.py_name, annotation))
            component_body.append(
                cst.ClassDef(
                    name=cst.Name(global_meta.py_name),
                    bases=[],
                    body=cst.IndentedBlock(body=inner_body),
                )
            )

        post_body.append(
            cst.ClassDef(
                name=cst.Name(component.py_name),
                bases=[
                    cst.Arg(
                        value=cst.Attribute(
                            value=cst.Name("slint"), attr=cst.Name("Component")
                        )
                    )
                ],
                body=cst.IndentedBlock(body=component_body),
            )
        )
        post_body.append(cst.EmptyLine())

    bindings: dict[str, str] = {}
    for component in artifacts.components:
        bindings[component.name] = component.py_name
    for struct in artifacts.structs:
        bindings[struct.name] = struct.py_name
    for enum_meta in artifacts.enums:
        if not enum_meta.is_builtin:
            bindings[enum_meta.name] = enum_meta.py_name

    for orig, alias in artifacts.named_exports:
        alias_name = _normalize_prop(alias)
        target = bindings.get(orig, _normalize_prop(orig))
        post_body.append(_stmt(f"{alias_name} = {target}"))
        post_body.append(cst.EmptyLine())

    module_body: list[cst.CSTNode] = [
        _stmt("from __future__ import annotations"),
        cst.EmptyLine(),
    ]

    import_statements: list[cst.CSTNode] = []

    if needs_enum_import:
        import_statements.append(_stmt("import enum"))

    typing_names = sorted(typing_imports)
    if typing_names:
        import_statements.append(_stmt(_format_import("typing", typing_names)))

    if artifacts.components:
        import_statements.append(_stmt("import slint"))

    if import_statements:
        module_body.extend(import_statements)
        module_body.append(cst.EmptyLine())

    module_body.extend(post_body)

    module = cst.Module(body=module_body)  # type: ignore[arg-type]
    path.write_text(module.code, encoding="utf-8")


def write_package_init(
    path: Path,
    *,
    source_relative: str,
    artifacts: ModuleArtifacts,
) -> None:
    def _stmt(code: str) -> cst.BaseStatement:
        return cst.parse_statement(code)

    header: list[cst.CSTNode] = [
        cst.EmptyLine(
            comment=cst.Comment(f"# Generated by slint.codegen from {source_relative}")
        )
    ]

    body: list[cst.CSTNode] = [
        _stmt("from __future__ import annotations"),
        cst.EmptyLine(),
        _stmt("from . import enums, structs"),
    ]

    export_bindings = _collect_export_bindings(artifacts, include_builtin_enums=False)
    symbol_names = list(export_bindings.values())

    if symbol_names:
        body.append(cst.EmptyLine())
        body.append(_stmt(_format_import("._generated", symbol_names)))

    enum_names = {enum.name for enum in artifacts.enums if not enum.is_builtin}
    struct_names = {struct.name for struct in artifacts.structs}
    component_names = {component.name for component in artifacts.components}
    allowed_for_init = enum_names | struct_names | component_names

    alias_names, alias_statements = _collect_named_aliases(
        artifacts,
        export_bindings,
        allowed_originals=allowed_for_init,
    )

    if alias_statements:
        body.append(cst.EmptyLine())
        for stmt in alias_statements:
            body.append(_stmt(stmt))

    export_names = _unique_preserve_order(
        symbol_names + alias_names + ["enums", "structs"]
    )
    body.append(cst.EmptyLine())
    all_list = cst.List(
        elements=[cst.Element(cst.SimpleString(repr(name))) for name in export_names]
    )
    body.append(
        cst.SimpleStatementLine(
            [
                cst.Assign(
                    targets=[cst.AssignTarget(cst.Name("__all__"))],
                    value=all_list,
                )
            ]
        )
    )

    module = cst.Module(body=header + body)  # type: ignore[arg-type]
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(module.code, encoding="utf-8")


def write_package_init_stub(path: Path, *, artifacts: ModuleArtifacts) -> None:
    def _stmt(code: str) -> cst.BaseStatement:
        return cst.parse_statement(code)

    body: list[cst.CSTNode] = [
        _stmt("from __future__ import annotations"),
        cst.EmptyLine(),
        _stmt("from . import enums, structs"),
    ]

    export_bindings = _collect_export_bindings(artifacts, include_builtin_enums=False)
    symbol_names = list(export_bindings.values())

    if symbol_names:
        body.append(cst.EmptyLine())
        body.append(_stmt(_format_import("._generated", symbol_names)))

    enum_original = {enum.name for enum in artifacts.enums if not enum.is_builtin}
    struct_original = {struct.name for struct in artifacts.structs}
    component_original = {component.name for component in artifacts.components}
    allowed_for_init = enum_original | struct_original | component_original
    alias_names, alias_statements = _collect_named_aliases(
        artifacts,
        export_bindings,
        allowed_originals=set(allowed_for_init),
    )

    if alias_statements:
        body.append(cst.EmptyLine())
        for stmt in alias_statements:
            body.append(_stmt(stmt))

    export_names = _unique_preserve_order(
        symbol_names + alias_names + ["enums", "structs"]
    )
    body.append(cst.EmptyLine())
    all_list = cst.List(
        elements=[cst.Element(cst.SimpleString(repr(name))) for name in export_names]
    )
    body.append(
        cst.SimpleStatementLine(
            [
                cst.Assign(
                    targets=[cst.AssignTarget(cst.Name("__all__"))],
                    value=all_list,
                )
            ]
        )
    )

    module = cst.Module(body=body)  # type: ignore[arg-type]
    path.write_text(module.code, encoding="utf-8")


def write_package_enums(
    path: Path, *, source_relative: str, artifacts: ModuleArtifacts
) -> None:
    def _stmt(code: str) -> cst.BaseStatement:
        return cst.parse_statement(code)

    header: list[cst.CSTNode] = [
        cst.EmptyLine(
            comment=cst.Comment(f"# Generated by slint.codegen from {source_relative}")
        )
    ]

    export_bindings = _collect_export_bindings(artifacts, include_builtin_enums=False)
    user_enum_names = [enum.py_name for enum in artifacts.enums if not enum.is_builtin]

    body: list[cst.CSTNode] = [
        _stmt("from __future__ import annotations"),
    ]

    if user_enum_names:
        body.append(cst.EmptyLine())
        body.append(_stmt(_format_import("._generated", user_enum_names)))

    enum_originals = {enum.name for enum in artifacts.enums if not enum.is_builtin}
    alias_names, alias_statements = _collect_named_aliases(
        artifacts,
        export_bindings,
        allowed_originals=enum_originals,
    )

    if alias_statements:
        body.append(cst.EmptyLine())
        for stmt in alias_statements:
            body.append(_stmt(stmt))

    export_names = _unique_preserve_order(user_enum_names + alias_names)
    body.append(cst.EmptyLine())
    all_list = cst.List(
        elements=[cst.Element(cst.SimpleString(repr(name))) for name in export_names]
    )
    body.append(
        cst.SimpleStatementLine(
            [
                cst.Assign(
                    targets=[cst.AssignTarget(cst.Name("__all__"))],
                    value=all_list,
                )
            ]
        )
    )

    module = cst.Module(body=header + body)  # type: ignore[arg-type]
    path.write_text(module.code, encoding="utf-8")


def write_package_enums_stub(path: Path, *, artifacts: ModuleArtifacts) -> None:
    def _stmt(code: str) -> cst.BaseStatement:
        return cst.parse_statement(code)

    export_bindings = _collect_export_bindings(artifacts, include_builtin_enums=False)
    user_enum_names = [enum.py_name for enum in artifacts.enums if not enum.is_builtin]

    body: list[cst.CSTNode] = [
        _stmt("from __future__ import annotations"),
    ]

    if user_enum_names:
        body.append(cst.EmptyLine())
        body.append(_stmt(_format_import("._generated", user_enum_names)))

    enum_originals = {enum.name for enum in artifacts.enums if not enum.is_builtin}
    alias_names, alias_statements = _collect_named_aliases(
        artifacts,
        export_bindings,
        allowed_originals=enum_originals,
    )

    if alias_statements:
        body.append(cst.EmptyLine())
        for stmt in alias_statements:
            body.append(_stmt(stmt))

    export_names = _unique_preserve_order(user_enum_names + alias_names)
    body.append(cst.EmptyLine())
    all_list = cst.List(
        elements=[cst.Element(cst.SimpleString(repr(name))) for name in export_names]
    )
    body.append(
        cst.SimpleStatementLine(
            [
                cst.Assign(
                    targets=[cst.AssignTarget(cst.Name("__all__"))],
                    value=all_list,
                )
            ]
        )
    )

    module = cst.Module(body=body)  # type: ignore[arg-type]
    path.write_text(module.code, encoding="utf-8")


def write_package_structs(
    path: Path, *, source_relative: str, artifacts: ModuleArtifacts
) -> None:
    def _stmt(code: str) -> cst.BaseStatement:
        return cst.parse_statement(code)

    header: list[cst.CSTNode] = [
        cst.EmptyLine(
            comment=cst.Comment(f"# Generated by slint.codegen from {source_relative}")
        )
    ]

    export_bindings = _collect_export_bindings(artifacts, include_builtin_enums=False)
    struct_names = [struct.py_name for struct in artifacts.structs]

    body: list[cst.CSTNode] = [
        _stmt("from __future__ import annotations"),
    ]

    if struct_names:
        body.append(cst.EmptyLine())
        body.append(_stmt(_format_import("._generated", struct_names)))

    struct_originals = {struct.name for struct in artifacts.structs}
    alias_names, alias_statements = _collect_named_aliases(
        artifacts,
        export_bindings,
        allowed_originals=struct_originals,
    )

    if alias_statements:
        body.append(cst.EmptyLine())
        for stmt in alias_statements:
            body.append(_stmt(stmt))

    export_names = _unique_preserve_order(struct_names + alias_names)
    body.append(cst.EmptyLine())
    all_list = cst.List(
        elements=[cst.Element(cst.SimpleString(repr(name))) for name in export_names]
    )
    body.append(
        cst.SimpleStatementLine(
            [
                cst.Assign(
                    targets=[cst.AssignTarget(cst.Name("__all__"))],
                    value=all_list,
                )
            ]
        )
    )

    module = cst.Module(body=header + body)  # type: ignore[arg-type]
    path.write_text(module.code, encoding="utf-8")


def write_package_structs_stub(path: Path, *, artifacts: ModuleArtifacts) -> None:
    def _stmt(code: str) -> cst.BaseStatement:
        return cst.parse_statement(code)

    export_bindings = _collect_export_bindings(artifacts, include_builtin_enums=False)
    struct_names = [struct.py_name for struct in artifacts.structs]

    body: list[cst.CSTNode] = [
        _stmt("from __future__ import annotations"),
    ]

    if struct_names:
        body.append(cst.EmptyLine())
        body.append(_stmt(_format_import("._generated", struct_names)))

    struct_originals = {struct.name for struct in artifacts.structs}
    alias_names, alias_statements = _collect_named_aliases(
        artifacts,
        export_bindings,
        allowed_originals=struct_originals,
    )

    if alias_statements:
        body.append(cst.EmptyLine())
        for stmt in alias_statements:
            body.append(_stmt(stmt))

    export_names = _unique_preserve_order(struct_names + alias_names)
    body.append(cst.EmptyLine())
    all_list = cst.List(
        elements=[cst.Element(cst.SimpleString(repr(name))) for name in export_names]
    )
    body.append(
        cst.SimpleStatementLine(
            [
                cst.Assign(
                    targets=[cst.AssignTarget(cst.Name("__all__"))],
                    value=all_list,
                )
            ]
        )
    )

    module = cst.Module(body=body)  # type: ignore[arg-type]
    path.write_text(module.code, encoding="utf-8")


def format_callable_annotation(callback: "CallbackMeta") -> str:
    args = callback.arg_types
    return_type = callback.return_type

    args_literal = ", ".join(args)
    arg_repr = f"[{args_literal}]" if args_literal else "[]"
    return f"Callable[{arg_repr}, {return_type}]"


__all__ = [
    "module_relative_path_expr",
    "write_python_module",
    "write_stub_module",
    "write_package_init",
    "write_package_init_stub",
    "write_package_enums",
    "write_package_enums_stub",
    "write_package_structs",
    "write_package_structs_stub",
]
