# Copyright Â© SixtyFPS GmbH <info@slint.dev>
# SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-Slint-Royalty-free-2.0 OR LicenseRef-Slint-Software-3.0

# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import abc
import builtins
import datetime
import enum
import os
import pathlib
import typing
from typing import Self

@typing.final
class AsyncAdapter:
    def __new__(cls, fd: builtins.int) -> Self: ...
    def wait_for_readable(self, callback: typing.Any) -> None: ...
    def wait_for_writable(self, callback: typing.Any) -> None: ...

@typing.final
class Brush:
    r"""
    A brush is a data structure that is used to describe how a shape, such as a rectangle, path or even text,
    shall be filled. A brush can also be applied to the outline of a shape, that means the fill of the outline itself.

    Brushes can only be constructed from solid colors.

    **Note:** In future, we plan to reduce this constraint and allow for declaring graidient brushes programmatically.
    """
    @property
    def color(self) -> Color:
        r"""
        The brush's color.
        """
    def __new__(cls, maybe_value: typing.Optional[Color] = None) -> Self: ...
    def is_transparent(self) -> builtins.bool:
        r"""
        Returns true if this brush contains a fully transparent color (alpha value is zero).
        """
    def is_opaque(self) -> builtins.bool:
        r"""
        Returns true if this brush is fully opaque.
        """
    def brighter(self, factor: builtins.float) -> Brush:
        r"""
        Returns a new version of this brush that has the brightness increased
        by the specified factor. This is done by calling `Color.brighter` on
        all the colors of this brush.
        """
    def darker(self, factor: builtins.float) -> Brush:
        r"""
        Returns a new version of this brush that has the brightness decreased
        by the specified factor. This is done by calling `Color.darker` on
        all the color of this brush.
        """
    def transparentize(self, amount: builtins.float) -> Brush:
        r"""
        Returns a new version of this brush with the opacity decreased by `factor`.

        The transparency is obtained by multiplying the alpha channel by `(1 - factor)`.

        See also `Color.transparentize`.
        """
    def with_alpha(self, alpha: builtins.float) -> Brush:
        r"""
        Returns a new version of this brush with the related color's opacities
        set to `alpha`.
        """
    def __eq__(self, other: Brush) -> builtins.bool: ...

@typing.final
class CallbackInfo:
    @property
    def name(self) -> builtins.str: ...
    @property
    def parameters(self) -> builtins.list[CallbackParameter]: ...
    @property
    def return_type(self) -> builtins.str: ...

@typing.final
class CallbackParameter:
    @property
    def name(self) -> typing.Optional[builtins.str]: ...
    @property
    def python_type(self) -> builtins.str: ...

@typing.final
class Color:
    r"""
    A Color object represents a color in the RGB color space with an alpha. Each color channel and the alpha is represented
    as an 8-bit integer. The alpha channel is 0 for fully transparent and 255 for fully opaque.

    Construct colors from a CSS color string, or by specifying the red, green, blue, and (optional) alpha channels in a dict.
    """
    @property
    def red(self) -> builtins.int:
        r"""
        The red channel.
        """
    @property
    def green(self) -> builtins.int:
        r"""
        The green channel.
        """
    @property
    def blue(self) -> builtins.int:
        r"""
        The blue channel.
        """
    @property
    def alpha(self) -> builtins.int:
        r"""
        The alpha channel.
        """
    def __new__(
        cls,
        maybe_value: typing.Optional[
            builtins.str | PyColorInput.RgbaColor | PyColorInput.RgbColor
        ] = None,
    ) -> Self: ...
    def brighter(self, factor: builtins.float) -> Color:
        r"""
        Returns a new color that is brighter than this color by the given factor.
        """
    def darker(self, factor: builtins.float) -> Color:
        r"""
        Returns a new color that is darker than this color by the given factor.
        """
    def transparentize(self, factor: builtins.float) -> Color:
        r"""
        Returns a new version of this color with the opacity decreased by `factor`.

        The transparency is obtained by multiplying the alpha channel by `(1 - factor)`.
        """
    def mix(self, other: Color, factor: builtins.float) -> Color:
        r"""
        Returns a new color that is a mix of this color and `other`. The specified factor is
        clamped to be between `0.0` and `1.0` and then applied to this color, while `1.0 - factor`
        is applied to `other`.
        """
    def with_alpha(self, alpha: builtins.float) -> Color:
        r"""
        Returns a new version of this color with the opacity set to `alpha`.
        """
    def __str__(self) -> builtins.str: ...
    def __eq__(self, other: Color) -> builtins.bool: ...

@typing.final
class CompilationResult:
    @property
    def component_names(self) -> builtins.list[builtins.str]: ...
    @property
    def diagnostics(self) -> builtins.list[PyDiagnostic]: ...
    @property
    def structs_and_enums(
        self,
    ) -> tuple[
        builtins.dict[builtins.str, typing.Any], builtins.dict[builtins.str, typing.Any]
    ]: ...
    @property
    def named_exports(self) -> builtins.list[tuple[builtins.str, builtins.str]]: ...
    @property
    def resource_paths(self) -> builtins.list[pathlib.Path]: ...
    def component(self, name: builtins.str) -> typing.Optional[ComponentDefinition]: ...

@typing.final
class Compiler:
    @property
    def include_paths(self) -> builtins.list[pathlib.Path]: ...
    @include_paths.setter
    def include_paths(self, value: builtins.list[pathlib.Path]) -> None: ...
    @property
    def style(self) -> typing.Optional[builtins.str]: ...
    @style.setter
    def style(self, value: builtins.str) -> None: ...
    @property
    def library_paths(self) -> builtins.dict[builtins.str, pathlib.Path]: ...
    @library_paths.setter
    def library_paths(
        self, value: builtins.dict[builtins.str, pathlib.Path]
    ) -> None: ...
    def __new__(cls) -> Self: ...
    def set_translation_domain(self, domain: builtins.str) -> None: ...
    def build_from_path(
        self, path: builtins.str | os.PathLike | pathlib.Path
    ) -> CompilationResult: ...
    def build_from_source(
        self, source_code: builtins.str, path: builtins.str | os.PathLike | pathlib.Path
    ) -> CompilationResult: ...

@typing.final
class ComponentDefinition:
    @property
    def name(self) -> builtins.str: ...
    @property
    def properties(self) -> builtins.dict[builtins.str, ValueType]: ...
    @property
    def callbacks(self) -> builtins.list[builtins.str]: ...
    @property
    def functions(self) -> builtins.list[builtins.str]: ...
    @property
    def globals(self) -> builtins.list[builtins.str]: ...
    def property_infos(self) -> builtins.list[PropertyInfo]: ...
    def callback_infos(self) -> builtins.list[CallbackInfo]: ...
    def function_infos(self) -> builtins.list[FunctionInfo]: ...
    def global_properties(
        self, name: builtins.str
    ) -> typing.Optional[builtins.dict[builtins.str, ValueType]]: ...
    def global_callbacks(
        self, name: builtins.str
    ) -> typing.Optional[builtins.list[builtins.str]]: ...
    def global_functions(
        self, name: builtins.str
    ) -> typing.Optional[builtins.list[builtins.str]]: ...
    def global_property_infos(
        self, global_name: builtins.str
    ) -> typing.Optional[builtins.list[PropertyInfo]]: ...
    def global_callback_infos(
        self, global_name: builtins.str
    ) -> typing.Optional[builtins.list[CallbackInfo]]: ...
    def global_function_infos(
        self, global_name: builtins.str
    ) -> typing.Optional[builtins.list[FunctionInfo]]: ...
    def callback_returns_void(self, callback_name: builtins.str) -> builtins.bool: ...
    def global_callback_returns_void(
        self, global_name: builtins.str, callback_name: builtins.str
    ) -> builtins.bool: ...
    def create(self) -> ComponentInstance: ...

@typing.final
class ComponentInstance:
    @property
    def definition(self) -> ComponentDefinition: ...
    def get_property(self, name: builtins.str) -> typing.Any: ...
    def set_property(self, name: builtins.str, value: typing.Any) -> None: ...
    def get_global_property(
        self, global_name: builtins.str, prop_name: builtins.str
    ) -> typing.Any: ...
    def set_global_property(
        self, global_name: builtins.str, prop_name: builtins.str, value: typing.Any
    ) -> None: ...
    def invoke(self, callback_name: builtins.str, *args: typing.Any) -> typing.Any: ...
    def invoke_global(
        self, global_name: builtins.str, callback_name: builtins.str, *args: typing.Any
    ) -> typing.Any: ...
    def set_callback(self, name: builtins.str, callable: typing.Any) -> None: ...
    def set_global_callback(
        self,
        global_name: builtins.str,
        callback_name: builtins.str,
        callable: typing.Any,
    ) -> None: ...
    def show(self) -> None: ...
    def hide(self) -> None: ...
    def __clear__(self) -> None: ...

@typing.final
class FunctionInfo:
    @property
    def name(self) -> builtins.str: ...
    @property
    def parameters(self) -> builtins.list[CallbackParameter]: ...
    @property
    def return_type(self) -> builtins.str: ...

@typing.final
class Image:
    r"""
    Image objects can be set on Slint Image elements for display. Use `Image.load_from_path` to construct Image
    objects from a path to an image file on disk.
    """
    @property
    def size(self) -> tuple[builtins.int, builtins.int]:
        r"""
        The size of the image as tuple of `width` and `height`.
        """
    @property
    def width(self) -> builtins.int:
        r"""
        The width of the image in pixels.
        """
    @property
    def height(self) -> builtins.int:
        r"""
        The height of the image in pixels.
        """
    @property
    def path(self) -> typing.Optional[pathlib.Path]:
        r"""
        The path of the image if it was loaded from disk, or None.
        """
    def __new__(cls) -> Self: ...
    @staticmethod
    def load_from_path(path: builtins.str | os.PathLike | pathlib.Path) -> Image:
        r"""
        Loads the image from the specified path. Returns None if the image can't be loaded.
        """
    @staticmethod
    def load_from_svg_data(data: typing.Sequence[builtins.int]) -> Image:
        r"""
        Creates a new image from a string that describes the image in SVG format.
        """
    @staticmethod
    def load_from_array(array: typing.Any) -> Image:
        r"""
        Creates a new image from an array-like object that implements the [Buffer Protocol](https://docs.python.org/3/c-api/buffer.html).
        Use this function to import images created by third-party modules such as matplotlib or Pillow.

        The array must satisfy certain contraints to represent an image:

         - The buffer's format needs to be `B` (unsigned char)
         - The shape must be a tuple of (height, width, bytes-per-pixel)
         - If a stride is defined, the row stride must be equal to width * bytes-per-pixel, and the column stride must equal the bytes-per-pixel.
         - A value of 3 for bytes-per-pixel is interpreted as RGB image, a value of 4 means RGBA.

        The image is created by performing a deep copy of the array's data. Subsequent changes to the buffer are not automatically
        reflected in a previously created Image.

        Example of importing a matplot figure into an image:
        ```python
        import slint
        import matplotlib

        from matplotlib.backends.backend_agg import FigureCanvasAgg
        from matplotlib.figure import Figure

        fig = Figure(figsize=(5, 4), dpi=100)
        canvas = FigureCanvasAgg(fig)
        ax = fig.add_subplot()
        ax.plot([1, 2, 3])
        canvas.draw()

        buffer = canvas.buffer_rgba()
        img = slint.Image.load_from_array(buffer)
        ```

        Example of loading an image with Pillow:
        ```python
        import slint
        from PIL import Image
        import numpy as np

        pil_img = Image.open("hello.jpeg")
        array = np.array(pil_img)
        img = slint.Image.load_from_array(array)
        ```
        """

@typing.final
class PropertyInfo:
    @property
    def name(self) -> builtins.str: ...
    @property
    def python_type(self) -> builtins.str: ...

class PyColorInput:
    @typing.final
    class ColorStr(PyColorInput):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.str: ...
        def __new__(cls, _0: builtins.str) -> Self: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...

    class RgbaColor(typing.TypedDict):
        red: builtins.int
        green: builtins.int
        blue: builtins.int
        alpha: builtins.int

    class RgbColor(typing.TypedDict):
        red: builtins.int
        green: builtins.int
        blue: builtins.int

    ...

@typing.final
class PyDiagnostic:
    @property
    def level(self) -> DiagnosticLevel: ...
    @property
    def message(self) -> builtins.str: ...
    @property
    def column_number(self) -> builtins.int: ...
    @property
    def line_number(self) -> builtins.int: ...
    @property
    def source_file(self) -> typing.Optional[pathlib.Path]: ...
    def __str__(self) -> builtins.str: ...

class PyModelBase(abc.ABC):
    def __new__(cls) -> Self: ...
    def init_self(self, self_ref: typing.Any) -> None: ...
    def notify_row_added(self, index: builtins.int, count: builtins.int) -> None:
        r"""
        Call this method from a sub-class to notify the views that
        `count` rows have been added starting at `index`.
        """
    def notify_row_changed(self, index: builtins.int) -> None:
        r"""
        Call this method from a sub-class to notify the views that a row has changed.
        """
    def notify_row_removed(self, index: builtins.int, count: builtins.int) -> None:
        r"""
        Call this method from a sub-class to notify the views that
        `count` rows have been removed starting at `index`.
        """
    @abc.abstractmethod
    def row_count(self) -> builtins.int:
        r"""
        Returns the number of rows available in the model.
        """
    @abc.abstractmethod
    def row_data(self, _row: builtins.int) -> typing.Optional[typing.Any]:
        r"""
        Returns the data for the given row in the model.
        """
    @abc.abstractmethod
    def set_row_data(self, _row: builtins.int, _value: typing.Any) -> None:
        r"""
        Call this method on mutable models to change the data for the given row.
        The UI will also call this method when modifying a model's data.
        Re-implement this method in a sub-class to handle the change.
        """
    def __clear__(self) -> None: ...

class PyStruct:
    def __getattr__(self, key: builtins.str) -> typing.Any: ...
    def __setattr__(self, key: builtins.str, value: typing.Any) -> None: ...
    def __iter__(self) -> PyStructFieldIterator: ...
    def __copy__(self) -> PyStruct: ...
    def __clear__(self) -> None: ...

@typing.final
class PyStructFieldIterator:
    def __iter__(self) -> PyStructFieldIterator: ...
    def __next__(self) -> typing.Any: ...

@typing.final
class ReadOnlyRustModel:
    def row_count(self) -> builtins.int: ...
    def row_data(self, row: builtins.int) -> typing.Any: ...
    def __len__(self) -> builtins.int: ...
    def __iter__(self) -> ReadOnlyRustModelIterator: ...
    def __getitem__(self, index: builtins.int) -> typing.Any: ...

@typing.final
class ReadOnlyRustModelIterator:
    def __iter__(self) -> ReadOnlyRustModelIterator: ...
    def __next__(self) -> typing.Any: ...

@typing.final
class RgbColor:
    @property
    def red(self) -> builtins.int: ...
    @red.setter
    def red(self, value: builtins.int) -> None: ...
    @property
    def green(self) -> builtins.int: ...
    @green.setter
    def green(self, value: builtins.int) -> None: ...
    @property
    def blue(self) -> builtins.int: ...
    @blue.setter
    def blue(self, value: builtins.int) -> None: ...

@typing.final
class RgbaColor:
    @property
    def red(self) -> builtins.int: ...
    @red.setter
    def red(self, value: builtins.int) -> None: ...
    @property
    def green(self) -> builtins.int: ...
    @green.setter
    def green(self, value: builtins.int) -> None: ...
    @property
    def blue(self) -> builtins.int: ...
    @blue.setter
    def blue(self, value: builtins.int) -> None: ...
    @property
    def alpha(self) -> builtins.int: ...
    @alpha.setter
    def alpha(self, value: builtins.int) -> None: ...

@typing.final
class SlintToPyValue: ...

@typing.final
class Timer:
    r"""
    Timer is a handle to the timer system that triggers a callback after a specified
    period of time.

    Use `Timer.start()` to create a timer that that repeatedly triggers a callback, or
    `Timer.single_shot()` to trigger a callback only once.

    The timer will automatically stop when garbage collected. You must keep the Timer object
    around for as long as you want the timer to keep firing.

    ```python
    class AppWindow(...)
        def __init__(self):
            super().__init__()
            self.my_timer = None

        @slint.callback
        def button_clicked(self):
            self.my_timer = slint.Timer()
            self.my_timer.start(timedelta(seconds=1), self.do_something)

        def do_something(self):
            pass
    ```

    Timers can only be used in the thread that runs the Slint event loop. They don't
    fire if used in another thread.
    """
    @property
    def running(self) -> builtins.bool:
        r"""
        Set to true if the timer is running; false otherwise.
        """
    @property
    def interval(self) -> datetime.timedelta: ...
    @interval.setter
    def interval(self, value: datetime.timedelta) -> None:
        r"""
        The duration of timer.

        When setting this property and the timer is running (see `Timer.running`),
        then the time when the callback will be next invoked is re-calculated to be in the
        specified duration relative to when this property is set.
        """
    def __new__(cls) -> Self: ...
    def start(
        self, mode: TimerMode, interval: datetime.timedelta, callback: typing.Any
    ) -> None:
        r"""
        Starts the timer with the given mode and interval, in order for the callback to called when the
        timer fires. If the timer has been started previously and not fired yet, then it will be restarted.

        Arguments:
        * `mode`: The timer mode to apply, i.e. whether to repeatedly fire the timer or just once.
        * `interval`: The duration from now until when the timer should firethe first time, and subsequently
           for `TimerMode.Repeated` timers.
        * `callback`: The function to call when the time has been reached or exceeded.
        """
    @staticmethod
    def single_shot(duration: datetime.timedelta, callback: typing.Any) -> None:
        r"""
        Starts the timer with the duration and the callback to called when the
        timer fires. It is fired only once and then deleted.

        Arguments:
        * `duration`: The duration from now until when the timer should fire.
        * `callback`: The function to call when the time has been reached or exceeded.
        """
    def stop(self) -> None:
        r"""
        Stops the previously started timer. Does nothing if the timer has never been started.
        """
    def restart(self) -> None:
        r"""
        Restarts the timer. If the timer was previously started by calling `Timer.start()`
        with a duration and callback, then the time when the callback will be next invoked
        is re-calculated to be in the specified duration relative to when this function is called.

        Does nothing if the timer was never started.
        """

@typing.final
class DiagnosticLevel(enum.Enum):
    Error = ...
    Warning = ...

@typing.final
class TimerMode(enum.Enum):
    r"""
    The TimerMode specifies what should happen after the timer fired.

    Used by the `Timer.start()` function.
    """

    SingleShot = ...
    r"""
    A SingleShot timer is fired only once.
    """
    Repeated = ...
    r"""
    A Repeated timer is fired repeatedly until it is stopped or dropped.
    """

@typing.final
class ValueType(enum.Enum):
    Void = ...
    Number = ...
    String = ...
    Bool = ...
    Model = ...
    Struct = ...
    Brush = ...
    Image = ...
    Enumeration = ...

def init_translations(translations: typing.Any) -> None: ...
def invoke_from_event_loop(callable: typing.Any) -> None: ...
def quit_event_loop() -> None: ...
def run_event_loop() -> None: ...
def set_xdg_app_id(app_id: builtins.str) -> None: ...
