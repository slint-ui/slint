# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import abc
import builtins
import datetime
import enum
import os
import pathlib
import typing

@typing.final
class AsyncAdapter:
    def __new__(cls, fd: builtins.int) -> AsyncAdapter: ...
    def wait_for_readable(self, callback: typing.Any) -> None: ...
    def wait_for_writable(self, callback: typing.Any) -> None: ...

@typing.final
class Brush:
    r"""
    A brush is a data structure that is used to describe how a shape, such as a rectangle, path or even text,
    shall be filled. A brush can also be applied to the outline of a shape, that means the fill of the outline itself.
    
    Brushes can only be constructed from solid colors.
    
    **Note:** In future, we plan to reduce this constraint and allow for declaring graidient brushes programmatically.
    """
    @property
    def color(self) -> Color:
        r"""
        The brush's color.
        """
    def __new__(cls, maybe_value: typing.Optional[Color] = None) -> Brush: ...
    def is_transparent(self) -> builtins.bool:
        r"""
        Returns true if this brush contains a fully transparent color (alpha value is zero).
        """
    def is_opaque(self) -> builtins.bool:
        r"""
        Returns true if this brush is fully opaque.
        """
    def brighter(self, factor: builtins.float) -> Brush:
        r"""
        Returns a new version of this brush that has the brightness increased
        by the specified factor. This is done by calling `Color.brighter` on
        all the colors of this brush.
        """
    def darker(self, factor: builtins.float) -> Brush:
        r"""
        Returns a new version of this brush that has the brightness decreased
        by the specified factor. This is done by calling `Color.darker` on
        all the color of this brush.
        """
    def transparentize(self, amount: builtins.float) -> Brush:
        r"""
        Returns a new version of this brush with the opacity decreased by `factor`.
        
        The transparency is obtained by multiplying the alpha channel by `(1 - factor)`.
        
        See also `Color.transparentize`.
        """
    def with_alpha(self, alpha: builtins.float) -> Brush:
        r"""
        Returns a new version of this brush with the related color's opacities
        set to `alpha`.
        """
    def __eq__(self, other: Brush) -> builtins.bool: ...

@typing.final
class CallbackInfo:
    @property
    def name(self) -> builtins.str: ...
    @property
    def parameters(self) -> builtins.list[CallbackParameter]: ...
    @property
    def return_type(self) -> builtins.str: ...

@typing.final
class CallbackParameter:
    @property
    def name(self) -> typing.Optional[builtins.str]: ...
    @property
    def python_type(self) -> builtins.str: ...

@typing.final
class Color:
    r"""
    A Color object represents a color in the RGB color space with an alpha. Each color channel and the alpha is represented
    as an 8-bit integer. The alpha channel is 0 for fully transparent and 255 for fully opaque.
    
    Construct colors from a CSS color string, or by specifying the red, green, blue, and (optional) alpha channels in a dict.
    """
    @property
    def red(self) -> builtins.int:
        r"""
        The red channel.
        """
    @property
    def green(self) -> builtins.int:
        r"""
        The green channel.
        """
    @property
    def blue(self) -> builtins.int:
        r"""
        The blue channel.
        """
    @property
    def alpha(self) -> builtins.int:
        r"""
        The alpha channel.
        """
    def __new__(cls, maybe_value: typing.Optional[builtins.str | PyColorInput.RgbaColor | PyColorInput.RgbColor] = None) -> Color: ...
    def brighter(self, factor: builtins.float) -> Color:
        r"""
        Returns a new color that is brighter than this color by the given factor.
        """
    def darker(self, factor: builtins.float) -> Color:
        r"""
        Returns a new color that is darker than this color by the given factor.
        """
    def transparentize(self, factor: builtins.float) -> Color:
        r"""
        Returns a new version of this color with the opacity decreased by `factor`.
        
        The transparency is obtained by multiplying the alpha channel by `(1 - factor)`.
        """
    def mix(self, other: Color, factor: builtins.float) -> Color:
        r"""
        Returns a new color that is a mix of this color and `other`. The specified factor is
        clamped to be between `0.0` and `1.0` and then applied to this color, while `1.0 - factor`
        is applied to `other`.
        """
    def with_alpha(self, alpha: builtins.float) -> Color:
        r"""
        Returns a new version of this color with the opacity set to `alpha`.
        """
    def __str__(self) -> builtins.str: ...
    def __eq__(self, other: Color) -> builtins.bool: ...

@typing.final
class CompilationResult:
    @property
    def component_names(self) -> builtins.list[builtins.str]: ...
    @property
    def diagnostics(self) -> builtins.list[PyDiagnostic]: ...
    @property
    def structs_and_enums(self) -> tuple[builtins.dict[builtins.str, typing.Any], builtins.dict[builtins.str, typing.Any]]: ...
    @property
    def named_exports(self) -> builtins.list[tuple[builtins.str, builtins.str]]: ...
    @property
    def resource_paths(self) -> builtins.list[pathlib.Path]: ...
    def component(self, name: builtins.str) -> typing.Optional[ComponentDefinition]: ...

@typing.final
class Compiler:
    @property
    def include_paths(self) -> builtins.list[pathlib.Path]: ...
    @include_paths.setter
    def include_paths(self, value: builtins.list[pathlib.Path]) -> None: ...
    @property
    def style(self) -> typing.Optional[builtins.str]: ...
    @style.setter
    def style(self, value: builtins.str) -> None: ...
    @property
    def library_paths(self) -> builtins.dict[builtins.str, pathlib.Path]: ...
    @library_paths.setter
    def library_paths(self, value: builtins.dict[builtins.str, pathlib.Path]) -> None: ...
    def __new__(cls) -> Compiler: ...
    def set_translation_domain(self, domain: builtins.str) -> None: ...
    def build_from_path(self, path: builtins.str | os.PathLike | pathlib.Path) -> CompilationResult: ...
    def build_from_source(self, source_code: builtins.str, path: builtins.str | os.PathLike | pathlib.Path) -> CompilationResult: ...

@typing.final
class ComponentDefinition:
    @property
    def name(self) -> builtins.str: ...
    @property
    def properties(self) -> builtins.dict[builtins.str, ValueType]: ...
    @property
    def callbacks(self) -> builtins.list[builtins.str]: ...
    @property
    def functions(self) -> builtins.list[builtins.str]: ...
    @property
    def globals(self) -> builtins.list[builtins.str]: ...
    def property_infos(self) -> builtins.list[PropertyInfo]: ...
    def callback_infos(self) -> builtins.list[CallbackInfo]: ...
    def function_infos(self) -> builtins.list[FunctionInfo]: ...
    def global_properties(self, name: builtins.str) -> builtins.dict[builtins.str, ValueType]: ...
    def global_callbacks(self, name: builtins.str) -> builtins.list[builtins.str]: ...
    def global_functions(self, name: builtins.str) -> builtins.list[builtins.str]: ...
    def global_property_infos(self, global_name: builtins.str) -> typing.Optional[builtins.list[PropertyInfo]]: ...
    def global_callback_infos(self, global_name: builtins.str) -> typing.Optional[builtins.list[CallbackInfo]]: ...
    def global_function_infos(self, global_name: builtins.str) -> typing.Optional[builtins.list[FunctionInfo]]: ...
    def callback_returns_void(self, callback_name: builtins.str) -> builtins.bool: ...
    def global_callback_returns_void(self, global_name: builtins.str, callback_name: builtins.str) -> builtins.bool: ...
    def create(self) -> ComponentInstance: ...

@typing.final
class ComponentInstance:
    @property
    def definition(self) -> ComponentDefinition: ...
    def get_property(self, name: builtins.str) -> typing.Any: ...
    def set_property(self, name: builtins.str, value: typing.Any) -> None: ...
    def get_global_property(self, global_name: builtins.str, prop_name: builtins.str) -> typing.Any: ...
    def set_global_property(self, global_name: builtins.str, prop_name: builtins.str, value: typing.Any) -> None: ...
    def invoke(self, callback_name: builtins.str, *args: typing.Any) -> typing.Any: ...
    def invoke_global(self, global_name: builtins.str, callback_name: builtins.str, *args: typing.Any) -> typing.Any: ...
    def set_callback(self, name: builtins.str, callable: typing.Any) -> None: ...
    def set_global_callback(self, global_name: builtins.str, callback_name: builtins.str, callable: typing.Any) -> None: ...
    def show(self) -> None: ...
    def hide(self) -> None: ...
    def on_close_requested(self, callable: typing.Any) -> None: ...
    def dispatch_close_requested_event(self) -> None: ...
    def __clear__(self) -> None: ...

@typing.final
class DropEvent:
    @property
    def mime_type(self) -> typing.Any: ...
    @mime_type.setter
    def mime_type(self, value: typing.Any) -> None: ...
    @property
    def data(self) -> typing.Any: ...
    @data.setter
    def data(self, value: typing.Any) -> None: ...
    @property
    def position(self) -> typing.Any: ...
    @position.setter
    def position(self, value: typing.Any) -> None: ...
    def __init__(self, *, mime_type: typing.Any = ..., data: typing.Any = ..., position: typing.Any = ...) -> None: ...

@typing.final
class FontMetrics:
    @property
    def ascent(self) -> typing.Any: ...
    @ascent.setter
    def ascent(self, value: typing.Any) -> None: ...
    @property
    def descent(self) -> typing.Any: ...
    @descent.setter
    def descent(self, value: typing.Any) -> None: ...
    @property
    def x_height(self) -> typing.Any: ...
    @x_height.setter
    def x_height(self, value: typing.Any) -> None: ...
    @property
    def cap_height(self) -> typing.Any: ...
    @cap_height.setter
    def cap_height(self, value: typing.Any) -> None: ...
    def __init__(self, *, ascent: typing.Any = ..., descent: typing.Any = ..., x_height: typing.Any = ..., cap_height: typing.Any = ...) -> None: ...

@typing.final
class FunctionInfo:
    @property
    def name(self) -> builtins.str: ...
    @property
    def parameters(self) -> builtins.list[CallbackParameter]: ...
    @property
    def return_type(self) -> builtins.str: ...

@typing.final
class Image:
    r"""
    Image objects can be set on Slint Image elements for display. Use `Image.load_from_path` to construct Image
    objects from a path to an image file on disk.
    """
    @property
    def size(self) -> tuple[builtins.int, builtins.int]:
        r"""
        The size of the image as tuple of `width` and `height`.
        """
    @property
    def width(self) -> builtins.int:
        r"""
        The width of the image in pixels.
        """
    @property
    def height(self) -> builtins.int:
        r"""
        The height of the image in pixels.
        """
    @property
    def path(self) -> typing.Optional[pathlib.Path]:
        r"""
        The path of the image if it was loaded from disk, or None.
        """
    def __new__(cls) -> Image: ...
    @staticmethod
    def load_from_path(path: builtins.str | os.PathLike | pathlib.Path) -> Image:
        r"""
        Loads the image from the specified path. Returns None if the image can't be loaded.
        """
    @staticmethod
    def load_from_svg_data(data: typing.Sequence[builtins.int]) -> Image:
        r"""
        Creates a new image from a string that describes the image in SVG format.
        """
    @staticmethod
    def load_from_array(array: typing.Any) -> Image:
        r"""
        Creates a new image from an array-like object that implements the [Buffer Protocol](https://docs.python.org/3/c-api/buffer.html).
        Use this function to import images created by third-party modules such as matplotlib or Pillow.
        
        The array must satisfy certain contraints to represent an image:
        
         - The buffer's format needs to be `B` (unsigned char)
         - The shape must be a tuple of (height, width, bytes-per-pixel)
         - If a stride is defined, the row stride must be equal to width * bytes-per-pixel, and the column stride must equal the bytes-per-pixel.
         - A value of 3 for bytes-per-pixel is interpreted as RGB image, a value of 4 means RGBA.
        
        The image is created by performing a deep copy of the array's data. Subsequent changes to the buffer are not automatically
        reflected in a previously created Image.
        
        Example of importing a matplot figure into an image:
        ```python
        import slint
        import matplotlib
        
        from matplotlib.backends.backend_agg import FigureCanvasAgg
        from matplotlib.figure import Figure
        
        fig = Figure(figsize=(5, 4), dpi=100)
        canvas = FigureCanvasAgg(fig)
        ax = fig.add_subplot()
        ax.plot([1, 2, 3])
        canvas.draw()
        
        buffer = canvas.buffer_rgba()
        img = slint.Image.load_from_array(buffer)
        ```
        
        Example of loading an image with Pillow:
        ```python
        import slint
        from PIL import Image
        import numpy as np
        
        pil_img = Image.open("hello.jpeg")
        array = np.array(pil_img)
        img = slint.Image.load_from_array(array)
        ```
        """

@typing.final
class KeyEvent:
    @property
    def text(self) -> typing.Any: ...
    @text.setter
    def text(self, value: typing.Any) -> None: ...
    @property
    def modifiers(self) -> typing.Any: ...
    @modifiers.setter
    def modifiers(self, value: typing.Any) -> None: ...
    @property
    def repeat(self) -> typing.Any: ...
    @repeat.setter
    def repeat(self, value: typing.Any) -> None: ...
    def __init__(self, *, text: typing.Any = ..., modifiers: typing.Any = ..., repeat: typing.Any = ...) -> None: ...

@typing.final
class KeyboardModifiers:
    @property
    def alt(self) -> typing.Any: ...
    @alt.setter
    def alt(self, value: typing.Any) -> None: ...
    @property
    def control(self) -> typing.Any: ...
    @control.setter
    def control(self, value: typing.Any) -> None: ...
    @property
    def shift(self) -> typing.Any: ...
    @shift.setter
    def shift(self, value: typing.Any) -> None: ...
    @property
    def meta(self) -> typing.Any: ...
    @meta.setter
    def meta(self, value: typing.Any) -> None: ...
    def __init__(self, *, alt: typing.Any = ..., control: typing.Any = ..., shift: typing.Any = ..., meta: typing.Any = ...) -> None: ...

@typing.final
class MenuEntry:
    @property
    def title(self) -> typing.Any: ...
    @title.setter
    def title(self, value: typing.Any) -> None: ...
    @property
    def icon(self) -> typing.Any: ...
    @icon.setter
    def icon(self, value: typing.Any) -> None: ...
    @property
    def id(self) -> typing.Any: ...
    @id.setter
    def id(self, value: typing.Any) -> None: ...
    @property
    def enabled(self) -> typing.Any: ...
    @enabled.setter
    def enabled(self, value: typing.Any) -> None: ...
    @property
    def checkable(self) -> typing.Any: ...
    @checkable.setter
    def checkable(self, value: typing.Any) -> None: ...
    @property
    def checked(self) -> typing.Any: ...
    @checked.setter
    def checked(self, value: typing.Any) -> None: ...
    @property
    def has_sub_menu(self) -> typing.Any: ...
    @has_sub_menu.setter
    def has_sub_menu(self, value: typing.Any) -> None: ...
    @property
    def is_separator(self) -> typing.Any: ...
    @is_separator.setter
    def is_separator(self, value: typing.Any) -> None: ...
    def __init__(self, *, title: typing.Any = ..., icon: typing.Any = ..., id: typing.Any = ..., enabled: typing.Any = ..., checkable: typing.Any = ..., checked: typing.Any = ..., has_sub_menu: typing.Any = ..., is_separator: typing.Any = ...) -> None: ...

@typing.final
class PointerEvent:
    @property
    def button(self) -> typing.Any: ...
    @button.setter
    def button(self, value: typing.Any) -> None: ...
    @property
    def kind(self) -> typing.Any: ...
    @kind.setter
    def kind(self, value: typing.Any) -> None: ...
    @property
    def modifiers(self) -> typing.Any: ...
    @modifiers.setter
    def modifiers(self, value: typing.Any) -> None: ...
    def __init__(self, *, button: typing.Any = ..., kind: typing.Any = ..., modifiers: typing.Any = ...) -> None: ...

@typing.final
class PointerScrollEvent:
    @property
    def delta_x(self) -> typing.Any: ...
    @delta_x.setter
    def delta_x(self, value: typing.Any) -> None: ...
    @property
    def delta_y(self) -> typing.Any: ...
    @delta_y.setter
    def delta_y(self, value: typing.Any) -> None: ...
    @property
    def modifiers(self) -> typing.Any: ...
    @modifiers.setter
    def modifiers(self, value: typing.Any) -> None: ...
    def __init__(self, *, delta_x: typing.Any = ..., delta_y: typing.Any = ..., modifiers: typing.Any = ...) -> None: ...

@typing.final
class PropertyInfo:
    @property
    def name(self) -> builtins.str: ...
    @property
    def python_type(self) -> builtins.str: ...

class PyColorInput:
    @typing.final
    class ColorStr(PyColorInput):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.str: ...
        def __new__(cls, _0: builtins.str) -> PyColorInput.ColorStr: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    class RgbaColor(typing.TypedDict):
        red: builtins.int
        green: builtins.int
        blue: builtins.int
        alpha: builtins.int
    
    class RgbColor(typing.TypedDict):
        red: builtins.int
        green: builtins.int
        blue: builtins.int
    
    ...

@typing.final
class PyDiagnostic:
    @property
    def level(self) -> DiagnosticLevel: ...
    @property
    def message(self) -> builtins.str: ...
    @property
    def column_number(self) -> builtins.int: ...
    @property
    def line_number(self) -> builtins.int: ...
    @property
    def source_file(self) -> typing.Optional[pathlib.Path]: ...
    def __str__(self) -> builtins.str: ...

class PyModelBase(abc.ABC):
    def init_self(self, self_ref: typing.Any) -> None: ...
    def notify_row_added(self, index: builtins.int, count: builtins.int) -> None:
        r"""
        Call this method from a sub-class to notify the views that
        `count` rows have been added starting at `index`.
        """
    def notify_row_changed(self, index: builtins.int) -> None:
        r"""
        Call this method from a sub-class to notify the views that a row has changed.
        """
    def notify_row_removed(self, index: builtins.int, count: builtins.int) -> None:
        r"""
        Call this method from a sub-class to notify the views that
        `count` rows have been removed starting at `index`.
        """
    @abc.abstractmethod
    def row_count(self) -> builtins.int:
        r"""
        Returns the number of rows available in the model.
        """
    @abc.abstractmethod
    def row_data(self, _row: builtins.int) -> typing.Optional[typing.Any]:
        r"""
        Returns the data for the given row in the model.
        """
    @abc.abstractmethod
    def set_row_data(self, _row: builtins.int, _value: typing.Any) -> None:
        r"""
        Call this method on mutable models to change the data for the given row.
        The UI will also call this method when modifying a model's data.
        Re-implement this method in a sub-class to handle the change.
        """
    def __clear__(self) -> None: ...

class PyStruct:
    def __getattr__(self, key: builtins.str) -> typing.Any: ...
    def __setattr__(self, key: builtins.str, value: typing.Any) -> None: ...
    def __iter__(self) -> PyStructFieldIterator: ...
    def __copy__(self) -> PyStruct: ...
    def __clear__(self) -> None: ...

@typing.final
class PyStructFieldIterator:
    def __iter__(self) -> PyStructFieldIterator: ...
    def __next__(self) -> typing.Any: ...

@typing.final
class ReadOnlyRustModel:
    def row_count(self) -> builtins.int: ...
    def row_data(self, row: builtins.int) -> typing.Any: ...
    def __len__(self) -> builtins.int: ...
    def __iter__(self) -> ReadOnlyRustModelIterator: ...
    def __getitem__(self, index: builtins.int) -> typing.Any: ...

@typing.final
class ReadOnlyRustModelIterator:
    def __iter__(self) -> ReadOnlyRustModelIterator: ...
    def __next__(self) -> typing.Any: ...

@typing.final
class RgbColor:
    @property
    def red(self) -> builtins.int: ...
    @red.setter
    def red(self, value: builtins.int) -> None: ...
    @property
    def green(self) -> builtins.int: ...
    @green.setter
    def green(self, value: builtins.int) -> None: ...
    @property
    def blue(self) -> builtins.int: ...
    @blue.setter
    def blue(self, value: builtins.int) -> None: ...

@typing.final
class RgbaColor:
    @property
    def red(self) -> builtins.int: ...
    @red.setter
    def red(self, value: builtins.int) -> None: ...
    @property
    def green(self) -> builtins.int: ...
    @green.setter
    def green(self, value: builtins.int) -> None: ...
    @property
    def blue(self) -> builtins.int: ...
    @blue.setter
    def blue(self, value: builtins.int) -> None: ...
    @property
    def alpha(self) -> builtins.int: ...
    @alpha.setter
    def alpha(self, value: builtins.int) -> None: ...

@typing.final
class SlintToPyValue:
    ...

@typing.final
class StandardListViewItem:
    @property
    def text(self) -> typing.Any: ...
    @text.setter
    def text(self, value: typing.Any) -> None: ...
    def __init__(self, *, text: typing.Any = ...) -> None: ...

@typing.final
class StateInfo:
    @property
    def current_state(self) -> typing.Any: ...
    @current_state.setter
    def current_state(self, value: typing.Any) -> None: ...
    @property
    def previous_state(self) -> typing.Any: ...
    @previous_state.setter
    def previous_state(self, value: typing.Any) -> None: ...
    def __init__(self, *, current_state: typing.Any = ..., previous_state: typing.Any = ...) -> None: ...

@typing.final
class TableColumn:
    @property
    def title(self) -> typing.Any: ...
    @title.setter
    def title(self, value: typing.Any) -> None: ...
    @property
    def min_width(self) -> typing.Any: ...
    @min_width.setter
    def min_width(self, value: typing.Any) -> None: ...
    @property
    def horizontal_stretch(self) -> typing.Any: ...
    @horizontal_stretch.setter
    def horizontal_stretch(self, value: typing.Any) -> None: ...
    @property
    def sort_order(self) -> typing.Any: ...
    @sort_order.setter
    def sort_order(self, value: typing.Any) -> None: ...
    @property
    def width(self) -> typing.Any: ...
    @width.setter
    def width(self, value: typing.Any) -> None: ...
    def __init__(self, *, title: typing.Any = ..., min_width: typing.Any = ..., horizontal_stretch: typing.Any = ..., sort_order: typing.Any = ..., width: typing.Any = ...) -> None: ...

@typing.final
class Timer:
    r"""
    Timer is a handle to the timer system that triggers a callback after a specified
    period of time.
    
    Use `Timer.start()` to create a timer that that repeatedly triggers a callback, or
    `Timer.single_shot()` to trigger a callback only once.
    
    The timer will automatically stop when garbage collected. You must keep the Timer object
    around for as long as you want the timer to keep firing.
    
    ```python
    class AppWindow(...)
        def __init__(self):
            super().__init__()
            self.my_timer = None
    
        @slint.callback
        def button_clicked(self):
            self.my_timer = slint.Timer()
            self.my_timer.start(timedelta(seconds=1), self.do_something)
    
        def do_something(self):
            pass
    ```
    
    Timers can only be used in the thread that runs the Slint event loop. They don't
    fire if used in another thread.
    """
    @property
    def running(self) -> builtins.bool:
        r"""
        Set to true if the timer is running; false otherwise.
        """
    @property
    def interval(self) -> datetime.timedelta: ...
    @interval.setter
    def interval(self, value: datetime.timedelta) -> None:
        r"""
        The duration of timer.
        
        When setting this property and the timer is running (see `Timer.running`),
        then the time when the callback will be next invoked is re-calculated to be in the
        specified duration relative to when this property is set.
        """
    def __new__(cls) -> Timer: ...
    def start(self, mode: TimerMode, interval: datetime.timedelta, callback: typing.Any) -> None:
        r"""
        Starts the timer with the given mode and interval, in order for the callback to called when the
        timer fires. If the timer has been started previously and not fired yet, then it will be restarted.
        
        Arguments:
        * `mode`: The timer mode to apply, i.e. whether to repeatedly fire the timer or just once.
        * `interval`: The duration from now until when the timer should firethe first time, and subsequently
           for `TimerMode.Repeated` timers.
        * `callback`: The function to call when the time has been reached or exceeded.
        """
    @staticmethod
    def single_shot(duration: datetime.timedelta, callback: typing.Any) -> None:
        r"""
        Starts the timer with the duration and the callback to called when the
        timer fires. It is fired only once and then deleted.
        
        Arguments:
        * `duration`: The duration from now until when the timer should fire.
        * `callback`: The function to call when the time has been reached or exceeded.
        """
    def stop(self) -> None:
        r"""
        Stops the previously started timer. Does nothing if the timer has never been started.
        """
    def restart(self) -> None:
        r"""
        Restarts the timer. If the timer was previously started by calling `Timer.start()`
        with a duration and callback, then the time when the callback will be next invoked
        is re-calculated to be in the specified duration relative to when this function is called.
        
        Does nothing if the timer was never started.
        """

@typing.final
class AccessibleRole(enum.Enum):
    r"""
    This enum represents the different values for the `accessible-role` property, used to describe the
    role of an element in the context of assistive technology such as screen readers.
    """
    none = ...
    r"""
    The element isn't accessible.
    """
    button = ...
    r"""
    The element is a `Button` or behaves like one.
    """
    checkbox = ...
    r"""
    The element is a `CheckBox` or behaves like one.
    """
    combobox = ...
    r"""
    The element is a `ComboBox` or behaves like one.
    """
    groupbox = ...
    r"""
    The element is a `GroupBox` or behaves like one.
    """
    image = ...
    r"""
    The element is an `Image` or behaves like one. This is automatically applied to `Image` elements.
    """
    list = ...
    r"""
    The element is a `ListView` or behaves like one.
    """
    slider = ...
    r"""
    The element is a `Slider` or behaves like one.
    """
    spinbox = ...
    r"""
    The element is a `SpinBox` or behaves like one.
    """
    tab = ...
    r"""
    The element is a `Tab` or behaves like one.
    """
    tablist = ...
    r"""
    The element is similar to the tab bar in a `TabWidget`.
    """
    tabpanel = ...
    r"""
    The element is a container for tab content.
    """
    text = ...
    r"""
    The role for a `Text` element. This is automatically applied to `Text` elements.
    """
    table = ...
    r"""
    The role for a `TableView` or behaves like one.
    """
    tree = ...
    r"""
    The role for a TreeView or behaves like one. (Not provided yet)
    """
    progressindicator = ...
    r"""
    The element is a `ProgressIndicator` or behaves like one.
    """
    textinput = ...
    r"""
    The role for widget with editable text such as a `LineEdit` or a `TextEdit`.
    This is automatically applied to `TextInput` elements.
    """
    switch = ...
    r"""
    The element is a `Switch` or behaves like one.
    """
    listitem = ...
    r"""
    The element is an item in a `ListView`.
    """

@typing.final
class AnimationDirection(enum.Enum):
    r"""
    This enum describes the direction of an animation.
    """
    normal = ...
    r"""
    The ["normal" direction as defined in CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction#normal).
    """
    reverse = ...
    r"""
    The ["reverse" direction as defined in CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction#reverse).
    """
    alternate = ...
    r"""
    The ["alternate" direction as defined in CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction#alternate).
    """
    alternatereverse = ...
    r"""
    The ["alternate reverse" direction as defined in CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction#alternate-reverse).
    """

@typing.final
class ColorScheme(enum.Enum):
    r"""
    This enum indicates the color scheme used by the widget style. Use this to explicitly switch
    between dark and light schemes, or choose Unknown to fall back to the system default.
    """
    unknown = ...
    r"""
    The scheme is not known and a system wide setting configures this. This could mean that
    the widgets are shown in a dark or light scheme, but it could also be a custom color scheme.
    """
    dark = ...
    r"""
    The style chooses light colors for the background and dark for the foreground.
    """
    light = ...
    r"""
    The style chooses dark colors for the background and light for the foreground.
    """

@typing.final
class DiagnosticLevel(enum.Enum):
    Error = ...
    Warning = ...

@typing.final
class DialogButtonRole(enum.Enum):
    r"""
    This enum represents the value of the `dialog-button-role` property which can be added to
    any element within a `Dialog` to put that item in the button row, and its exact position
    depends on the role and the platform.
    """
    none = ...
    r"""
    This isn't a button meant to go into the bottom row
    """
    accept = ...
    r"""
    This is the role of the main button to click to accept the dialog. e.g. "Ok" or "Yes"
    """
    reject = ...
    r"""
    This is the role of the main button to click to reject the dialog. e.g. "Cancel" or "No"
    """
    apply = ...
    r"""
    This is the role of the "Apply" button
    """
    reset = ...
    r"""
    This is the role of the "Reset" button
    """
    help = ...
    r"""
    This is the role of the  "Help" button
    """
    action = ...
    r"""
    This is the role of any other button that performs another action.
    """

@typing.final
class EventResult(enum.Enum):
    r"""
    This enum describes whether an event was rejected or accepted by an event handler.
    """
    reject = ...
    r"""
    The event is rejected by this event handler and may then be handled by the parent item
    """
    accept = ...
    r"""
    The event is accepted and won't be processed further
    """

@typing.final
class FillRule(enum.Enum):
    r"""
    This enum describes the different ways of deciding what the inside of a shape described by a path shall be.
    """
    nonzero = ...
    r"""
    The ["nonzero" fill rule as defined in SVG](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule#nonzero).
    """
    evenodd = ...
    r"""
    The ["evenodd" fill rule as defined in SVG](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule#evenodd)
    """

@typing.final
class FocusReason(enum.Enum):
    r"""
    This enum describes the different reasons for a FocusEvent
    """
    programmatic = ...
    r"""
    A built-in function invocation caused the event (`.focus()`, `.clear-focus()`)
    """
    tabnavigation = ...
    r"""
    Keyboard navigation caused the event (tabbing)
    """
    pointerclick = ...
    r"""
    A mouse click caused the event
    """
    popupactivation = ...
    r"""
    A popup caused the event
    """
    windowactivation = ...
    r"""
    The window manager changed the active window and caused the event
    """

@typing.final
class ImageFit(enum.Enum):
    r"""
    This enum defines how the source image shall fit into an `Image` element.
    """
    fill = ...
    r"""
    Scales and stretches the source image to fit the width and height of the `Image` element.
    """
    contain = ...
    r"""
    The source image is scaled to fit into the `Image` element's dimension while preserving the aspect ratio.
    """
    cover = ...
    r"""
    The source image is scaled to cover into the `Image` element's dimension while preserving the aspect ratio.
    If the aspect ratio of the source image doesn't match the element's one, then the image will be clipped to fit.
    """
    preserve = ...
    r"""
    Preserves the size of the source image in logical pixels.
    The source image will still be scaled by the scale factor that applies to all elements in the window.
    Any extra space will be left blank.
    """

@typing.final
class ImageHorizontalAlignment(enum.Enum):
    r"""
    This enum specifies the horizontal alignment of the source image.
    """
    center = ...
    r"""
    Aligns the source image at the center of the `Image` element.
    """
    left = ...
    r"""
    Aligns the source image at the left of the `Image` element.
    """
    right = ...
    r"""
    Aligns the source image at the right of the `Image` element.
    """

@typing.final
class ImageRendering(enum.Enum):
    r"""
    This enum specifies how the source image will be scaled.
    """
    smooth = ...
    r"""
    The image is scaled with a linear interpolation algorithm.
    """
    pixelated = ...
    r"""
    The image is scaled with the nearest neighbor algorithm.
    """

@typing.final
class ImageTiling(enum.Enum):
    r"""
    This enum specifies how the source image will be tiled.
    """
    none = ...
    r"""
    The source image will not be tiled.
    """
    repeat = ...
    r"""
    The source image will be repeated to fill the `Image` element.
    """
    round = ...
    r"""
    The source image will be repeated and scaled to fill the `Image` element, ensuring an integer number of repetitions.
    """

@typing.final
class ImageVerticalAlignment(enum.Enum):
    r"""
    This enum specifies the vertical alignment of the source image.
    """
    center = ...
    r"""
    Aligns the source image at the center of the `Image` element.
    """
    top = ...
    r"""
    Aligns the source image at the top of the `Image` element.
    """
    bottom = ...
    r"""
    Aligns the source image at the bottom of the `Image` element.
    """

@typing.final
class InputType(enum.Enum):
    r"""
    This enum is used to define the type of the input field.
    """
    text = ...
    r"""
    The default value. This will render all characters normally
    """
    password = ...
    r"""
    This will render all characters with a character that defaults to "*"
    """
    number = ...
    r"""
    This will only accept and render number characters (0-9)
    """
    decimal = ...
    r"""
    This will accept and render characters if it's valid part of a decimal
    """

@typing.final
class LayoutAlignment(enum.Enum):
    r"""
    Enum representing the `alignment` property of a
    `HorizontalBox`, a `VerticalBox`,
    a `HorizontalLayout`, or `VerticalLayout`.
    """
    stretch = ...
    r"""
    Use the minimum size of all elements in a layout, distribute remaining space
    based on `*-stretch` among all elements.
    """
    center = ...
    r"""
    Use the preferred size for all elements, distribute remaining space evenly before the
    first and after the last element.
    """
    start = ...
    r"""
    Use the preferred size for all elements, put remaining space after the last element.
    """
    end = ...
    r"""
    Use the preferred size for all elements, put remaining space before the first
    element.
    """
    spacebetween = ...
    r"""
    Use the preferred size for all elements, distribute remaining space evenly between
    elements.
    """
    spacearound = ...
    r"""
    Use the preferred size for all elements, distribute remaining space evenly
    between the elements, and use half spaces at the start and end.
    """
    spaceevenly = ...
    r"""
    Use the preferred size for all elements, distribute remaining space evenly before the
    first element, after the last element and between elements.
    """

@typing.final
class LineCap(enum.Enum):
    r"""
    This enum describes the appearance of the ends of stroked paths.
    """
    butt = ...
    r"""
    The stroke ends with a flat edge that is perpendicular to the path.
    """
    round = ...
    r"""
    The stroke ends with a rounded edge.
    """
    square = ...
    r"""
    The stroke ends with a square projection beyond the path.
    """

@typing.final
class MouseCursor(enum.Enum):
    r"""
    This enum represents different types of mouse cursors. It's a subset of the mouse cursors available in CSS.
    For details and pictograms see the [MDN Documentation for cursor](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values).
    Depending on the backend and used OS unidirectional resize cursors may be replaced with bidirectional ones.
    """
    default = ...
    r"""
    The systems default cursor.
    """
    none = ...
    r"""
    No cursor is displayed.
    """
    help = ...
    r"""
    A cursor indicating help information.
    """
    pointer = ...
    r"""
    A pointing hand indicating a link.
    """
    progress = ...
    r"""
    The program is busy but can still be interacted with.
    """
    wait = ...
    r"""
    The program is busy.
    """
    crosshair = ...
    r"""
    A crosshair.
    """
    text = ...
    r"""
    A cursor indicating selectable text.
    """
    alias = ...
    r"""
    An alias or shortcut is being created.
    """
    copy = ...
    r"""
    A copy is being created.
    """
    move = ...
    r"""
    Something is to be moved.
    """
    nodrop = ...
    r"""
    Something can't be dropped here.
    """
    notallowed = ...
    r"""
    An action isn't allowed
    """
    grab = ...
    r"""
    Something is grabbable.
    """
    grabbing = ...
    r"""
    Something is being grabbed.
    """
    colresize = ...
    r"""
    Indicating that a column is resizable horizontally.
    """
    rowresize = ...
    r"""
    Indicating that a row is resizable vertically.
    """
    nresize = ...
    r"""
    Unidirectional resize north.
    """
    eresize = ...
    r"""
    Unidirectional resize east.
    """
    sresize = ...
    r"""
    Unidirectional resize south.
    """
    wresize = ...
    r"""
    Unidirectional resize west.
    """
    neresize = ...
    r"""
    Unidirectional resize north-east.
    """
    nwresize = ...
    r"""
    Unidirectional resize north-west.
    """
    seresize = ...
    r"""
    Unidirectional resize south-east.
    """
    swresize = ...
    r"""
    Unidirectional resize south-west.
    """
    ewresize = ...
    r"""
    Bidirectional resize east-west.
    """
    nsresize = ...
    r"""
    Bidirectional resize north-south.
    """
    neswresize = ...
    r"""
    Bidirectional resize north-east-south-west.
    """
    nwseresize = ...
    r"""
    Bidirectional resize north-west-south-east.
    """

@typing.final
class OperatingSystemType(enum.Enum):
    r"""
    This enum describes the detected operating system types.
    """
    android = ...
    r"""
    This variant includes any version of Android running mobile phones, tablets, as well as embedded Android devices.
    """
    ios = ...
    r"""
    This variant covers iOS running on iPhones and iPads.
    """
    macos = ...
    r"""
    This variant covers macOS running on Apple's Mac computers.
    """
    linux = ...
    r"""
    This variant covers any version of Linux, except Android.
    """
    windows = ...
    r"""
    This variant covers Microsoft Windows.
    """
    other = ...
    r"""
    This variant is reported when the operating system is none of the above.
    """

@typing.final
class Orientation(enum.Enum):
    r"""
    Represents the orientation of an element or widget such as the `Slider`.
    """
    horizontal = ...
    r"""
    Element is oriented horizontally.
    """
    vertical = ...
    r"""
    Element is oriented vertically.
    """

@typing.final
class PathEvent(enum.Enum):
    r"""
    PathEvent is a low-level data structure describing the composition of a path. Typically it is
    generated at compile time from a higher-level description, such as SVG commands.
    """
    begin = ...
    r"""
    The beginning of the path.
    """
    line = ...
    r"""
    A straight line on the path.
    """
    quadratic = ...
    r"""
    A quadratic bezier curve on the path.
    """
    cubic = ...
    r"""
    A cubic bezier curve on the path.
    """
    endopen = ...
    r"""
    The end of the path that remains open.
    """
    endclosed = ...
    r"""
    The end of a path that is closed.
    """

@typing.final
class PointerEventButton(enum.Enum):
    r"""
    This enum describes the different types of buttons for a pointer event,
    typically on a mouse or a pencil.
    """
    other = ...
    r"""
    A button that is none of left, right, middle, back or forward. For example,
    this is used for the task button on a mouse with many buttons.
    """
    left = ...
    r"""
    The left button.
    """
    right = ...
    r"""
    The right button.
    """
    middle = ...
    r"""
    The center button.
    """
    back = ...
    r"""
    The back button.
    """
    forward = ...
    r"""
    The forward button.
    """

@typing.final
class PointerEventKind(enum.Enum):
    r"""
    The enum reports what happened to the `PointerEventButton` in the event
    """
    cancel = ...
    r"""
    The action was cancelled.
    """
    down = ...
    r"""
    The button was pressed.
    """
    up = ...
    r"""
    The button was released.
    """
    move = ...
    r"""
    The pointer has moved,
    """

@typing.final
class PopupClosePolicy(enum.Enum):
    closeonclick = ...
    r"""
    Closes the `PopupWindow` when user clicks or presses the escape key.
    """
    closeonclickoutside = ...
    r"""
    Closes the `PopupWindow` when user clicks outside of the popup or presses the escape key.
    """
    noautoclose = ...
    r"""
    Does not close the `PopupWindow` automatically when user clicks.
    """

@typing.final
class ScrollBarPolicy(enum.Enum):
    r"""
    This enum describes the scrollbar visibility
    """
    asneeded = ...
    r"""
    Scrollbar will be visible only when needed
    """
    alwaysoff = ...
    r"""
    Scrollbar never shown
    """
    alwayson = ...
    r"""
    Scrollbar always visible
    """

@typing.final
class SortOrder(enum.Enum):
    r"""
    This enum represents the different values of the `sort-order` property.
    It's used to sort a `StandardTableView` by a column.
    """
    unsorted = ...
    r"""
    The column is unsorted.
    """
    ascending = ...
    r"""
    The column is sorted in ascending order.
    """
    descending = ...
    r"""
    The column is sorted in descending order.
    """

@typing.final
class StandardButtonKind(enum.Enum):
    r"""
    Use this enum to add standard buttons to a `Dialog`. The look and positioning
    of these `StandardButton`s depends on the environment
    (OS, UI environment, etc.) the application runs in.
    """
    ok = ...
    r"""
    A "OK" button that accepts a `Dialog`, closing it when clicked.
    """
    cancel = ...
    r"""
    A "Cancel" button that rejects a `Dialog`, closing it when clicked.
    """
    apply = ...
    r"""
    A "Apply" button that should accept values from a
    `Dialog` without closing it.
    """
    close = ...
    r"""
    A "Close" button, which should close a `Dialog` without looking at values.
    """
    reset = ...
    r"""
    A "Reset" button, which should reset the `Dialog` to its initial state.
    """
    help = ...
    r"""
    A "Help" button, which should bring up context related documentation when clicked.
    """
    yes = ...
    r"""
    A "Yes" button, used to confirm an action.
    """
    no = ...
    r"""
    A "No" button, used to deny an action.
    """
    abort = ...
    r"""
    A "Abort" button, used to abort an action.
    """
    retry = ...
    r"""
    A "Retry" button, used to retry a failed action.
    """
    ignore = ...
    r"""
    A "Ignore" button, used to ignore a failed action.
    """

@typing.final
class TextHorizontalAlignment(enum.Enum):
    r"""
    This enum describes the different types of alignment of text along the horizontal axis of a `Text` element.
    """
    left = ...
    r"""
    The text will be aligned with the left edge of the containing box.
    """
    center = ...
    r"""
    The text will be horizontally centered within the containing box.
    """
    right = ...
    r"""
    The text will be aligned to the right of the containing box.
    """

@typing.final
class TextOverflow(enum.Enum):
    r"""
    This enum describes the how the text appear if it is too wide to fit in the `Text` width.
    """
    clip = ...
    r"""
    The text will simply be clipped.
    """
    elide = ...
    r"""
    The text will be elided with `â€¦`.
    """

@typing.final
class TextStrokeStyle(enum.Enum):
    r"""
    This enum describes the positioning of a text stroke relative to the border of the glyphs in a `Text`.
    """
    outside = ...
    r"""
    The inside edge of the stroke is at the outer edge of the text.
    """
    center = ...
    r"""
    The center line of the stroke is at the outer edge of the text, like in Adobe Illustrator.
    """

@typing.final
class TextVerticalAlignment(enum.Enum):
    r"""
    This enum describes the different types of alignment of text along the vertical axis of a `Text` element.
    """
    top = ...
    r"""
    The text will be aligned to the top of the containing box.
    """
    center = ...
    r"""
    The text will be vertically centered within the containing box.
    """
    bottom = ...
    r"""
    The text will be aligned to the bottom of the containing box.
    """

@typing.final
class TextWrap(enum.Enum):
    r"""
    This enum describes the how the text wrap if it is too wide to fit in the `Text` width.
    """
    nowrap = ...
    r"""
    The text won't wrap, but instead will overflow.
    """
    wordwrap = ...
    r"""
    The text will be wrapped at word boundaries if possible, or at any location for very long words.
    """
    charwrap = ...
    r"""
    The text will be wrapped at any character. Currently only supported by the Qt and Software renderers.
    """

@typing.final
class TimerMode(enum.Enum):
    r"""
    The TimerMode specifies what should happen after the timer fired.
    
    Used by the `Timer.start()` function.
    """
    SingleShot = ...
    r"""
    A SingleShot timer is fired only once.
    """
    Repeated = ...
    r"""
    A Repeated timer is fired repeatedly until it is stopped or dropped.
    """

@typing.final
class ValueType(enum.Enum):
    Void = ...
    Number = ...
    String = ...
    Bool = ...
    Model = ...
    Struct = ...
    Brush = ...
    Image = ...
    Enumeration = ...

def init_translations(translations: typing.Any) -> None: ...

def invoke_from_event_loop(callable: typing.Any) -> None: ...

def quit_event_loop() -> None: ...

def run_event_loop() -> None: ...

def set_xdg_app_id(app_id: builtins.str) -> None: ...

