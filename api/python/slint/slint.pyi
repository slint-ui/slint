# Copyright Â© SixtyFPS GmbH <info@slint.dev>
# SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-Slint-Royalty-free-2.0 OR LicenseRef-Slint-Software-3.0

# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import datetime
import os
import pathlib
import typing
from typing import Any, List
from collections.abc import Callable
from enum import Enum, auto


class RgbColor:
    red: builtins.int
    green: builtins.int
    blue: builtins.int

class RgbaColor:
    red: builtins.int
    green: builtins.int
    blue: builtins.int
    alpha: builtins.int


class Color:
    red: builtins.int
    green: builtins.int
    blue: builtins.int
    alpha: builtins.int
    def __new__(cls,maybe_value:typing.Optional[builtins.str | RgbaColor | RgbColor | typing.Dict[str, int]] = None): ...
    def brighter(self, factor:builtins.float) -> "Color":
        ...

    def darker(self, factor:builtins.float) -> "Color":
        ...

    def transparentize(self, factor:builtins.float) -> "Color":
        ...

    def mix(self, other:"Image", factor:builtins.float) -> "Color":
        ...

    def with_alpha(self, alpha:builtins.float) -> "Color":
        ...

    def __str__(self) -> builtins.str:
        ...

    def __eq__(self, other:object) -> builtins.bool:
        ...



class Brush:
    color: Color
    def __new__(cls,maybe_value:typing.Optional[Color]): ...
    def is_transparent(self) -> builtins.bool:
        ...

    def is_opaque(self) -> builtins.bool:
        ...

    def brighter(self, factor:builtins.float) -> "Brush":
        ...

    def darker(self, factor:builtins.float) -> "Brush":
        ...

    def transparentize(self, amount:builtins.float) -> "Brush":
        ...

    def with_alpha(self, alpha:builtins.float) -> "Brush":
        ...

    def __eq__(self, other:object) -> builtins.bool:
        ...


class Image:
    r"""
    Image objects can be set on Slint Image elements for display. Construct Image objects from a path to an
    image file on disk, using `Image.load_from_path`.
    """
    size: tuple[builtins.int, builtins.int]
    width: builtins.int
    height: builtins.int
    path: typing.Optional[builtins.str]
    def __new__(cls,): ...
    @staticmethod
    def load_from_path(path:builtins.str | os.PathLike | pathlib.Path) -> "Image":
        r"""
        Loads the image from the specified path. Returns None if the image can't be loaded.
        """
        ...

    @staticmethod
    def load_from_svg_data(data:typing.Sequence[builtins.int]) -> "Image":
        r"""
        Creates a new image from a string that describes the image in SVG format.
        """
        ...


class TimerMode(Enum):
    SingleShot = auto()
    Repeated = auto()


class Timer:
    def __new__(cls,) -> "Timer": ...
    def start(self, mode:TimerMode, interval:datetime.timedelta, callback:typing.Any) -> None:
        ...

    @staticmethod
    def single_shot(duration:datetime.timedelta, callback:typing.Any) -> None:
        ...

    def stop(self) -> None:
        ...

    def restart(self) -> None:
        ...

    def running(self) -> builtins.bool:
        ...

    def set_interval(self, interval:datetime.timedelta) -> None:
        ...

def set_xdg_app_id(app_id: str):
    ...

def run_event_loop() -> None: ...

def quit_event_loop() -> None: ...

class PyModelBase:
    ...

class PyStruct(Any):
    ...


class ValueType(Enum):
    Void = auto()
    Number = auto()
    String = auto()
    Bool = auto()
    Model = auto()
    Struct = auto()
    Brush = auto()
    Image = auto()

class DiagnosticLevel(Enum):
    Error = auto()
    Warning = auto()

class PyDiagnostic:
    level: DiagnosticLevel
    message: str
    line_number: int
    column_number: int
    source_file: typing.Optional[str]


class ComponentInstance:
    def invoke(self, callback_name: str, *args): ...
    def invoke_global(self, global_name: str, callback_name: str, *args): ...
    def set_property(self, property_name: str, value: Any): ...
    def get_property(self, property_name: str): ...
    def set_callback(self, callback_name: str, callback: Callable[..., Any]): ...
    def set_global_callback(self, global_name: str, callback_name: str, callback: Callable[..., Any]): ...
    def set_global_property(self, global_name: str, property_name: str, value: Any): ...
    def get_global_property(self, global_name: str, property_name: str): ...


class ComponentDefinition:
    def create(self) -> ComponentInstance: ...
    name: str
    globals: list[str]
    functions: list[str]
    callbacks: list[str]
    properties: dict[str, ValueType]
    def global_functions(self, global_name: str) -> list[str]: ...
    def global_callbacks(self, global_name: str) -> list[str]: ...
    def global_properties(self, global_name: str) -> typing.Dict[str, ValueType]: ...


class CompilationResult:
    component_names: list[str]
    diagnostics: list[PyDiagnostic]
    def component(self, name: str) -> ComponentDefinition: ...

class Compiler:
    include_paths: list[str]
    def build_from_path(self, path:str) -> CompilationResult: ...
    def build_from_source(self, source:str, path: str) -> CompilationResult: ...
