---
// cSpell: ignore Backtab
title: Key Handling Overview
description: Key Handling Overview
---

import Link from '@slint/common-files/src/components/Link.astro';
import SpecialKeys from "../../../collections/enums/keys.md"

To handle keyboard input in Slint, use the `FocusScope` or individual `key-pressed` and `key-released` callbacks in various elements.
Keyboard input is delivered via [`KeyEvent`](#keyevent) data structures.
The primary field of this data structure is the `text` property, which holds all affected keys
encoded in a string.
Use the [`Key` namespace](#key-namespace) to identify known named keys.

To handle keyboard shortcuts, Slint uses a built-in <Link type="keyboard-shortcut" label="keyboard-shortcut" /> type, which is constructed from the `@keys` macro.
See [Keyboard Shortcuts](#keyboard-shortcuts).

## KeyEvent

 This structure is generated and passed to the key press and release callbacks of the `FocusScope` element.

- **`text`** (_string_):  The unicode representation of the key pressed.
- **`modifiers`** (_KeyboardModifiers_):  The keyboard modifiers active at the time of the key press event.
- **`repeat`** (_bool_):  This field is set to true for key press events that are repeated, i.e. the key is held down. It's always false for key release events.

## Keyboard Shortcuts

Use the <Link type="Shortcut" label="Shortcut element"/> inside a `FocusScope` to declare Keyboard shortcuts.
The Shortcut's `keys` property takes a `keyboard-shortcut` and invokes the `activated` callback when the shortcut is detected.
Note that only one shortcut can be activated by a given key event.
If two shortcuts share the same key event, it is undefined which one is activated.

The `keyboard-shortcut` type represents a key, combined with modifiers and is constructed with the `@keys` macro.

The `@keys(..)` macro accepts a key from the [`Key` namespace](#key-namespace), combined with any of these modifiers:

- `Meta` (⌃ control on macOS and Windows key on PC)
- `Control` (⌘ command on macOS)
- `Shift`
- `Alt` (⌥ option on macOS)

```slint playground
export component Example inherits Window {
    forward-focus: scope;

    scope := FocusScope {
        Shortcut {
            keys: @keys(Control + Q);
            activated => { debug("Quit shortcut activated"); }
        }

        Shortcut {
            keys: @keys(Control + S);
            activated => { debug("Save shortcut activated"); }
        }

        Text {
            text: "Press Control + Q or Control + S";
        }
    }
}
```

Use the `matches(..)` function on a `keyboard-shortcut` to check whether a given [`KeyEvent`](#keyevent) matches the shortcut.
Note that `keyboard-shortcut` does not deal with event propagation and capture on its own.
For ease-of-use prefer using a <Link type="Shortcut" label="Shortcut element"/> instead of manually matching against key events.

```slint
// Example component with custom event handling
export component MyComponent inherits Window {
  in property <keyboard-shortcut> copy-shortcut: @keys(Control + C);
  callback copy();

  Text { text: "Press Ctrl+C to copy"; }

  FocusScope {
    key-pressed(event) => {
      if root.copy-shortcut.matches(event) {
        debug("Copy shortcut pressed");
        root.copy();
        EventResult.accept
      } else {
        EventResult.reject
      }
    }
  }
}
```

### Different Keyboard Layouts

Using the `@keys(..)` macro with a key from the [`Key` namespace](#key-namespace) will handle different keyboard layouts for you and notify you of the most common issues regarding internationalization.

In general, a `keyboard-shortcut` will match a KeyEvent depending on the symbol that the keypress produces on the current layout, not the keys physical position on the keyboard.
So to match the `@keys(Control + Plus)` shortcut on a U.S. layout you must press "Control + Shift + `=`".
On a German layout however, only "Control + `+`" must be pressed, as Shift is not required there.

The `@keys(..)` macro allows you to explicitly control this behavior for Advanced Keyboard shortcuts, if needed.

### Advanced Keyboard Shortcuts

If possible, prefer to use a key from the [`Key` namespace](#key-namespace) inside `@keys(..)`.
If you absolutely need to define a shortcut to a different key, you can use a string literal inside the `@keys(..)` macro.
For example: `@keys(Control + "ä")`.

Note though that the `@keys(..)` macro no longer automatically handles different keyboard layouts and Shift behavior in this case.
The provided string is simply matched against the **lowercased** `text`, plus the modifiers of the given `KeyEvent`

To prevent issues with characters that entirely change their keycode when `Shift` (or sometimes `Alt` on macOS) is applied, you can use two additional special modifiers:

- `IgnoreShift`
- `IgnoreAlt`

When these keywords are added to the `@keys(..)` macro, the `keyboard-shortcut` will ignore the state of the corresponding modifier when matching.

For example, to support keyboard shortcuts that produce a Euro-Sign (€), add both `IgnoreShift` and `IgnoreAlt`: `@keys(Control + IgnoreShift + IgnoreAlt + "€")`.
This will allow your users to reach the shortcut on almost all keyboard layouts that have a key with this label.

As another example, `@keys(Control + Plus)` is equivalent to `@keys(Control + IgnoreShift + "+")`.

## Key Namespace

The `Key` namespace contains a list of well-known key codes (including any non-printable characters).

Note that alphabetic keys (e.g. Key.A-Key.Z) are represented as lowercase (e.g. "a"-"z").
Make sure to case-convert the [`KeyEvent`](#keyevent) `text` or the Key as necessary.

<SpecialKeys />
