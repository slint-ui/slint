# Recipes and Examples

This page provides a collection of common use-cases and how to implement them using Slint.

## Get Started

### A clickable Button

```slint
import { VerticalBox, Button } from "std-widgets.slint";
export Recipe := Window {
    property <int> counter: 0;
    VerticalBox {
        button := Button {
            text: "Button, pressed " + counter + " times";
            clicked => {
                counter += 1;
            }
        }
    }
}
```

In that first example, we see the basics of the Slint language.

 - We import the widgets `VerticalBox` and `Button` from the standard widgets library
   using the `import` statement. That statement can import widgets or your own component
   declared in different files. Built-in element such as `Window` or `Rectangle` do not
   need to be imported.
 - We declare the `Recipe` component using `:=`. That component is a `Window` and it contains
   a layout (`VerticalBox`) with one button.
 - The elements are just instantiated with their name and braces. They form a tree of elements.
   They can optionaly be named using `:=`
 - Elements can have properties and can be set with `:`. In this case the `Button` has a `text`
   property and it is assigned a binding that computes a string by concatenating some string
   literals, and the `counter` property.
 - You can declare custom properties with `property <...>`. Property need to have a type and can have
   a default value. This is how we declare the `counter` property in this example.
 - In addition to properties, element can also have callback. In this case we assigned a callback
   handler to the `clicked` callback of the button with `=> { ... }`
 - Properties are automatically re-evaluated once a dependency changes. The `text` binding of
   the button is going to be automatically re-computed when the `counter` is changed.


### React to a Button in native code

Instead of having code in the slint language to increment the counter, we will now do the same
in native code.

```slint
import { VerticalBox, Button } from "std-widgets.slint";
export Recipe := Window {
    property <int> counter: 0;
    callback button-pressed <=> button.clicked;
    VerticalBox {
        button := Button {
            text: "Button, pressed " + counter + " times";
        }
    }
}
```

We create a callback `button-pressed`  and using the `<=>` syntax, we bind it to the `button.clicked`.

Properties and callback declared on the root element of the main component will be exposed to the
native code. Note that `-` is replaced by `_`. In slint, `-` and `_` are equivalent and interchangable.
But this since `-` is not valid in identifier in native code, they are replaced by `_`.

<details data-snippet-language="rust">
<summary>Rust code</summary>

For technical reason in this example, we use `import {Recipe}` in the `slint!` macro, but
in real code, you can put the whole slint code in the `slint!` macro, or use a buyild script.


```rust,no_run
slint::slint!(import { Recipe } from "docs/recipes/button_native.slint";);

fn main() {
    let recipe = Recipe::new();
    let recipe_weak = recipe.as_weak();
    recipe.on_button_pressed(move || {
        let recipe = recipe_weak.upgrade().unwrap();
        let mut value = recipe.get_counter();
        value = value + 1;
        recipe.set_counter(value);
    });
    recipe.run();
}
```

A `struct Recipe` is generated by Slint. For each property, a getter (`get_counter`) and a setter (`set_counter`)
is generated. For the callback, a function to set the callback is generated (`on_button_pressed`)

The `Recipe` struct implements the [`slint::ComponentHandle`] trait. A component handle is an equivalent of `Rc`,
It is a handle to a Component which has a strong and a weak reference count. We call the `as_weak` function to
get a weak handle to the component which we can move into the callback.
We can't move a strong component because that would form a cycle. (The Component has ownership of the callback
which itself has ownership of its capture)
</details>

<details data-snippet-language="cpp">
<summary>C++ code</summary>
In C++ you can write

```cpp
#include "button_native.h"

int main(int argc, char **argv)
{
    auto recipe = Recipe::create();
    recipe->on_button_pressed([&]() {
        auto value = recipe->get_counter();
        value += 1;
        recipe->set_counter(value);
    });
    recipe->run();
}
```

Some simple boiler place needs to be done with cmake for the integration, so that the Slint compiler
generates the button_native.h header file from the Slint file. It contains the generated`class Recipe`.

For each property, a getter (`get_counter`) and a setter (`set_counter`)
is generated. For the callback, a function to set the callback is generated (`on_button_pressed`)

</details>

### Use property bindings to synchronize controls

```slint
import { VerticalBox, Slider } from "std-widgets.slint";
export Recipe := Window {
    VerticalBox {
        slider := Slider {
            maximum: 100;
        }
        Text {
            text: "Value: \{round(slider.value)}";
        }
    }
}
```

This example introduces the `Slider` widget.
It also introduces interpolation in string literal: you can use `\{...}` in them
and the code is rendered to a string.

## Animations

### Animate the position of an element


```slint
import { CheckBox } from "std-widgets.slint";
export Recipe := Window {
    width: 200px;
    height: 100px;

    rect := Rectangle {
        y: 5px;
        width: 40px;
        height: 40px;
        background: blue;
        animate x {
            duration: 500ms;
            easing: ease-in-out;
        }
    }


    CheckBox {
        y: 25px;
        text: "Align rect to the right";
        toggled => {
            if (self.checked) {
                 rect.x = parent.width - rect.width;
            } else {
                 rect.x = 0px;
            }
        }
    }
}
```

We'd usually use Layout or  Box to position elements, but in this case we do the
positioning manually using the `x`, `y`, `width`, `height` property.

Notice the `animate x` block that specify an animation that is run when the property
is changed. Either because the property is set in a callback, or if its binding value changes.

### Animation Sequence

```slint
import { CheckBox } from "std-widgets.slint";
export Recipe := Window {
    width: 200px;
    height: 100px;

    rect := Rectangle {
        y: 5px;
        width: 40px;
        height: 40px;
        background: blue;
        animate x {
            duration: 500ms;
            easing: ease-in-out;
        }
        animate y {
            duration: 250ms;
            delay: 500ms;
            easing: ease-in;
        }
    }


    CheckBox {
        y: 25px;
        text: "Align rect bottom right";
        toggled => {
            if (self.checked) {
                 rect.x = parent.width - rect.width;
                 rect.y = parent.height - rect.height;
            } else {
                 rect.x = 0px;
                 rect.y = 0px;
            }
        }
    }
}
```

We use `delay` to make one animation run after the other.

## States

### Associate multiple property values with states

```slint
import { HorizontalBox, VerticalBox, Button } from "std-widgets.slint";

Circle := Rectangle {
    width: 30px;
    height: 30px;
    border-radius: width / 2;
    animate x { duration: 250ms; easing: ease-in; }
    animate y { duration: 250ms; easing: ease-in-out; }
    animate background { duration: 250ms; }
}

export Recipe := Window {
    states [
        left-aligned when b1.pressed: {
            circle1.x: 0px; circle1.y: 40px; circle1.background: green;
            circle2.x: 0px; circle2.y: 0px; circle2.background: blue;
        }
        right-aligned when b2.pressed: {
            circle1.x: 170px; circle1.y: 70px; circle1.background: green;
            circle2.x: 170px; circle2.y: 00px; circle2.background: blue;
        }
    ]

    VerticalBox {
        HorizontalBox {
            max-height: min-height;
            b1 := Button {
                text: "State 1";
            }
            b2 := Button {
                text: "State 2";
            }
        }
        Rectangle {
            background: root.background.darker(20%);
            width: 200px;
            height: 100px;

            circle1 := Circle { background: green; x: 85px; }
            circle2 := Circle { background: green; x: 85px; y: 40px; }
        }
    }
}
```

### Transitions

```slint
import { HorizontalBox, VerticalBox, Button } from "std-widgets.slint";

Circle := Rectangle {
    width: 30px;
    height: 30px;
    border-radius: width / 2;
}

export Recipe := Window {
    states [
        left-aligned when b1.pressed: {
            circle1.x: 0px; circle1.y: 40px;
            circle2.x: 0px; circle2.y: 0px;
        }
        right-aligned when !b1.pressed: {
            circle1.x: 170px; circle1.y: 70px;
            circle2.x: 170px; circle2.y: 00px;
        }
    ]

    transitions [
        in left-aligned: {
            animate circle1.x, circle2.x { duration: 250ms; }
        }
        out left-aligned: {
            animate circle1.x, circle2.x { duration: 500ms; }
        }
    ]

    VerticalBox {
        HorizontalBox {
            max-height: min-height;
            b1 := Button {
                text: "Press and hold to change state";
            }
        }
        Rectangle {
            background: root.background.darker(20%);
            width: 250px;
            height: 100px;

            circle1 := Circle { background: green; x: 85px; }
            circle2 := Circle { background: blue; x: 85px; y: 40px; }
        }
    }
}
```

## Layouts

### Vertical

```slint
import { VerticalBox, Button } from "std-widgets.slint";
export Recipe := Window {
    VerticalBox {
        Button { text: "First"; }
        Button { text: "Second"; }
        Button { text: "Third"; }
    }
}
```

### Horizontal

```slint
import { HorizontalBox, Button } from "std-widgets.slint";
export Recipe := Window {
    HorizontalBox {
        Button { text: "First"; }
        Button { text: "Second"; }
        Button { text: "Third"; }
    }
}
```

### Grid

```slint
import { GridBox, Button, Slider } from "std-widgets.slint";
export Recipe := Window {
    GridBox {
        Row {
            Button { text: "First"; }
            Button { text: "Second"; }
        }
        Row {
            Button { text: "Third"; }
            Button { text: "Fourth"; }
        }
        Row {
            Slider {
                colspan: 2;
            }
        }
    }
}
```

## Global Callbacks

### Invoke a globally registered native callback from Slint

It is usefull to use Global Singleton to implement logic or store properties
set by the native code.

Please note that in the preview only visualize the slint code, but is not
connected to the native code.

```slint,no-preview
import { HorizontalBox, VerticalBox, LineEdit } from "std-widgets.slint";

export global Logic := {
    callback to-upper-case(string) -> string;
    // You can collect other global properties here
}

export Recipe := Window {
    VerticalBox {
        input := LineEdit {
            text: "Text to be transformed";
        }
        HorizontalBox {
            Text { text: "Transformed:"; }
            // Callback invoked in binding expression
            Text {
                text: {
                    Logic.to-upper-case(input.text);
                }
            }
        }
    }
}
```

<details  data-snippet-language="rust">
<summary>Rust code</summary>
In Rust you can set the callback like this:

```rust
slint::slint!{
import { HorizontalBox, VerticalBox, LineEdit } from "std-widgets.slint";

export global Logic := {
    callback to-upper-case(string) -> string;
    // You can collect other global properties here
}

export Recipe := Window {
    VerticalBox {
        input := LineEdit {
            text: "Text to be transformed";
        }
        HorizontalBox {
            Text { text: "Transformed:"; }
            // Callback invoked in binding expression
            Text {
                text: {
                    Logic.to-upper-case(input.text);
                }
            }
        }
    }
}
}

fn main() {
    let recipe = Recipe::new();
    recipe.global::<Logic>().on_to_upper_case(|string| {
        string.as_str().to_uppercase().into()
    });
    // ...
}
```
</details>

<details  data-snippet-language="cpp">
<summary>C++ code</summary>
In C++ you can set the callback like this:

```cpp
int main(int argc, char **argv)
{
    auto recipe = Recipe::create();
    recipe->global<Logic>().on_to_uppercase([](SharedString str) -> SharedString {
        std::string arg(str);
        std::transform(arg.begin(), arg.end(), arg.begin(), toupper);
        return SharedString(arg);
    });
    // ...
}
```
</details>


<!--

more content:

## Input Events

### Keyboard Input

Receive key events, pass them to native code

### Mouse and Touch Input

### Flickable

-->
