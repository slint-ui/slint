// Copyright Â© SixtyFPS GmbH <info@slint.dev>
// SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-Slint-Royalty-free-2.0 OR LicenseRef-Slint-Software-3.0

import { Palette } from "std-widgets.slint";
import { BrushKind, PropertyValue, PropertyValueKind } from "../../api.slint";
import { NameLabel } from "./basics.slint";
import { EditorSpaceSettings } from "../../components/styling.slint";
import { WindowManager } from "../../windowglobal.slint";
import { ColorIndicator } from "brush-helpers.slint";

component FocusBorder inherits Rectangle {
    in property <bool> has-focus;

    background: #326CCF;
    opacity: 0;

    animate opacity { duration: 150ms; }

    states [
        focused when root.has-focus: {
            opacity: 0.5;
        }
    ]
}

component CustomLineEdit {
    in-out property <string> text;
    property <bool> enabled: true;
    property <bool> has-focus: false;
    property <brush> fluent-text-control-border: Palette.color-scheme == ColorScheme.dark ? @linear-gradient(180deg, #FFFFFF14 99.98%, #FFFFFF8A 100%, #FFFFFF8A 100%) : @linear-gradient(180deg, #0000000F 99.99%, #00000073 100%, #00000073 100%);
    out property <brush> fluent-control-input-active: Palette.color-scheme == ColorScheme.dark ? #1E1E1EB3 : #FFFFFF;

    width: 100px;
    height: Palette.style-name == "cupertino" ? 22px : Palette.style-name == "fluent" ? 32px : 33px;

    FocusBorder {
        x: (parent.width - self.width) / 2;
        y: (parent.height - self.height) / 2;
        width: parent.width + 6px;
        height: parent.height + 6px;
        has-focus: root.has-focus;
    }

    background := Rectangle {
        background: Palette.control-background;
        border-width: 1px;
        border-color: Palette.style-name == "fluent" ? fluent-text-control-border : Palette.border;
        border-radius: Palette.style-name == "fluent" ? 4px : 0px;

        focus-border := Rectangle {
            x: parent.border-radius;
            y: parent.height - self.height;
            width: parent.width - 2 * parent.border-radius;
            height: 2px;
        }
    }

    @children

    states [
        focused when root.has-focus && Palette.style-name == "fluent": {
            background.background: fluent-control-input-active;
            background.border-color: Palette.border;
            focus-border.background: Palette.accent-background;
        }
    ]
}

// is the property a color? 
// is it code or an svg color: If so show the code edit button.
// At this point it can only be a valid #hex value. So only the color in-line is 
// shown and only the color picker can be launched

// is the property a brush? If so what type of brush?
// is it code or an svg color: If so show the code edit button.
// If its a a valid #hex value show that and be able to launch the picker in brush mode, but on the color tab.
// If its a linear gradient show linear + preview and let the brush picker be launched in brush mode and on the gradient tab.component 
// If its a radial gradient show radial + preview and let the brush picker be launched in brush mode and on the gradient tab.
export component InlineColorWidget inherits VerticalLayout {
    in property <bool> enabled;
    in property <string> property-name;
    in property <PropertyValue> property-value;

    private property <color> current-color: Colors.transparent;

    callback code-action();
    callback reset-action();

    callback test-color-binding(text: string) -> bool;
    callback set-color-binding(text: string);
    callback update-floating-editor();

    padding-left: 16px;
    spacing: EditorSpaceSettings.default-spacing;

    callback update-display-string(value: string);

    width: 100%;

    function apply-value() {
        root.current-color = self.property-value.value-brush;
    }

    private property <bool> has-focus;
    //TODO: main.has-focus;

    init => {
        apply-value();
    }

    changed has-focus => {
        if !self.has-focus {
            apply-value();
        }
    }

    changed property-value => {
        if self.property-value.kind != PropertyValueKind.color && self.property-value.kind != PropertyValueKind.brush {
            return;
        }
        if !self.has-focus {
            apply-value();
        }

        // Floating editors need to know the current property details. Call the update if something changes.
        if WindowManager.showing-color-picker && WindowManager.current-property-information.name == root.property-name {
            root.update-floating-editor();
        }
    }

    NameLabel {
        property-name: root.property-name;
        property-value: root.property-value;
    }

    HorizontalLayout {
        spacing: 4px;
        main := CustomLineEdit {
            ColorIndicator {
                x: 5px;
                y: (parent.height - self.height) / 2;
                color: root.current-color;
                clicked => {
                    root.update-floating-editor();
                }
            }
        }
    }


    // main := ColorMainContent {
    //     current-color <=> root.current-color;
    //     enabled <=> root.enabled;

    //     set-color-binding(text) => {
    //         root.set-color-binding(text);
    //     }

    //     test-color-binding(text) => {
    //         return root.test-color-binding(text);
    //     }

  
    // }
}
